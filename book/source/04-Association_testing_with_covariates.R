########################
# Libraries
########################

library(tidyverse)
library(PhenotypeSimulator)
library(GridLMM)
library(DT)
library(KRLS)
library(cowplot)
library(plotly)
library(gtools)
library(ggbeeswarm)

########################
# Paths
########################

working_dir = "/hps/nobackup/birney/users/ian/somites"
lts_dir = "/nfs/research/birney/users/ian/somites"

########################
# GridLMM functions
########################

my.invnorm = function(x) {
  res = rank(x)
  res = qnorm(res/(length(res)+0.5))
  return(res)
}

## No covariates

run_gwas <- function(d,m,p,invers_norm=F) {
  # Creates a vector of the prefix "snp" combined with the row number of positions
  ids = paste("snp", 1:nrow(m), sep="")
  # Adds this vector as first column of the DF of positions: now comprising `ids`, `CHROM`, `BIN_START`, `BIN_END`
  mm = data.frame(ids, m)
  # Also add these ids as column names to the sample x locus DF of genotypes 
  colnames(d) = ids
  # Rename columns of positions DF
  colnames(mm) = c("snp", "Chr", "pos")
  # Then pull just the first three columns
  mm = mm[,1:3]
  # Rename it as `map`
  map = mm
  # Get number of samples (rows) from genotype DF
  n_geno=nrow(d)
  # Create matrix of 1200 elements from 1 to 1200, with 10 columns
  Plots = matrix(1:1200,nc = 10)
  # Create matrix of row numbers for each element of the `Plots` matrix (1:1200)
  Plot_Row = row(Plots)
  # Create matrix of col numbers for each element of the `Plots` matrix (1:10)
  Plot_Col = col(Plots)
  # Create a data frame with "Genox" for each sample in the first column
  # And randomly sample `n_geno` times from `Plots`
  data = data.frame(Geno = paste0('Geno',1: n_geno), Plot = sample(Plots)[1:nrow(d)])
  # Add a column `Row` with the row number of each randomly-sampled element
  data$Row = Plot_Row[data$Plot]
  # Add a column `Col` with the row number of each randomly-sampled element
  data$Col = Plot_Col[data$Plot]
  # Add phenotype
  if(invers_norm) {
    ## Inverse-normalise
    data$y = my.invnorm(p[,2])
  } else {
    data$y = p[,2]
  }
  # Convert genotypes DF to matrix
  X = as.matrix(d)
  # Convert NAs to 0
  X[is.na(X)]=0
  # Add sample names to `X` as row names
  row.names(X) = data[,1]
  # Center genotypes by subtracting the mean for each marker (column) from the genotype value
  X_centered = sweep(X,2,colMeans(X),'-') # center marker genotypes
  # Use centered genotypes to create `K` kinship matrix
  K = tcrossprod(X_centered) / ncol(X_centered)
  # Make rownames and colnames of `K` the randomly sampled elements from `Plots`
  rownames(K) = colnames(K) = data$Plot
  # Calculate the spatial kernel
  field = data[,c('Row','Col')] # Pull out `Row` and `Col` columns
  dists = as.matrix(dist(field)) # Compute the distances 
  h = median(dists) # Calculate default tuning parameter `h`
  K_plot = KRLS::gausskernel(field,h^2/2); diag(K_plot)=1 # Compute the NxN distance matrix with pairwise with pairwise differences between rows as measured by a Gaussian Kernel
  rownames(K_plot) = colnames(K_plot) = data$Plot
  gwas = GridLMM_GWAS(
    formula = y~1 + (1|Geno) + (1|Plot), # the same error model is used for each marker. It is specified similarly to lmer
    test_formula = ~1, # this is the model for each marker. ~1 means an intercept for the marker. ~1 + cov means an intercept plus a slope on `cov` for each marker
    reduced_formula = ~0, # This is the null model for each test. ~0 means just the error model. ~1 means the null includes the intercept of the marker, but not anything additional
    data = data, # The dataframe to look for terms from the 3 models
    weights = NULL, # optional observation-specific weights
    X = X, # The matrix of markers. Note: This can be of dimension n_g x p, where n_g is the number of unique genotypes.
    X_ID = 'Geno', # The column of the data that identifies each genotype. Each level of data$Geno should match a rowname of X
    h2_start = NULL, # An optional vector of h2s to use as starting values for each random effect in the model. If NULL, will be calculated from the error model using GridLMM_ML
    h2_step = 0.01, # step size per random effect for testing alternate values of h2
    max_steps = 100, # maximum number of steps of size h2_step to take from h2_start
    X_map = map, # Optional. The marker positions.
    relmat = list(Plot = K), # A list of Kernel matrices for the random effects. If X_ID (here Geno) is not included in this list, then it is calculated as tcrossprod(Xc)/ncol(Xc) where Xc is the centered (and optionally scaled) X. If any random effects are described in `error_model` but not provided here, the Kernel is assumed to be the identity matrix
    centerX = TRUE, # Should the markers be centered when calculating the GRM (only will be done if needed for calculating the GRM),
    scaleX = FALSE, # Should the markers be scaled to have constant variance when calculating the GRM?
    fillNAX = FALSE, # Should missing marker data be filled in with the mean allele frequency?
    method = 'REML', # REML = Wald test, ML = LRT, BF = calculate Bayes factors
    mc.cores = my_detectCores(), # How many cores should be used for parallel processing. Unless X is large, tends to actually be faster with mc.cores = 1
    verbose = FALSE # Should progress be printed to the screen?
  )
  return(gwas)
}

# With Microscope as a covariate

run_gwas_with_covariates <- function(d,m,p,invers_norm=F, covariates = NULL) {
  # Creates a vector of the prefix "snp" combined with the row number of positions
  ids = paste("snp", 1:nrow(m), sep="")
  # Adds this vector as first column of the DF of positions: now comprising `ids`, `CHROM`, `BIN_START`, `BIN_END`
  mm = data.frame(ids, m)
  # Also add these ids as column names to the sample x locus DF of genotypes 
  colnames(d) = ids
  # Rename columns of positions DF
  colnames(mm) = c("snp", "Chr", "pos")
  # Then pull just the first three columns
  mm = mm[,1:3]
  # Rename it as `map`
  map = mm
  # Get number of samples (rows) from genotype DF
  n_geno=nrow(d)
  # Create matrix of 1200 elements from 1 to 1200, with 10 columns
  Plots = matrix(1:1200,nc = 10)
  # Create matrix of row numbers for each element of the `Plots` matrix (1:1200)
  Plot_Row = row(Plots)
  # Create matrix of col numbers for each element of the `Plots` matrix (1:10)
  Plot_Col = col(Plots)
  # Create a data frame with "Genox" for each sample in the first column
  # And randomly sample `n_geno` times from `Plots`
  data = data.frame(Geno = paste0('Geno',1: n_geno), Plot = sample(Plots)[1:nrow(d)])
  # Add a column `Row` with the row number of each randomly-sampled element
  data$Row = Plot_Row[data$Plot]
  # Add a column `Col` with the row number of each randomly-sampled element
  data$Col = Plot_Col[data$Plot]
  # Add phenotype
  if(invers_norm) {
    ## Inverse-normalise
    data = cbind(data, my.invnorm(p[,c(2, which(colnames(p) %in% covariates))])) # pull sample name and covariates
    colnames(data)[5] = "y" # rename phenotype as `y`
  } else {
    data = cbind(data, p[,c(2, which(colnames(p) %in% covariates))]) # pull sample name and covariates
    colnames(data)[5] = "y" # rename phenotype as `y`
  }
  # Convert genotypes DF to matrix
  X = as.matrix(d)
  # Convert NAs to 0
  X[is.na(X)]=0
  # Add sample names to `X` as row names
  row.names(X) = data[,1]
  # Center genotypes by subtracting the mean for each marker (column) from the genotype value
  X_centered = sweep(X,2,colMeans(X),'-') # center marker genotypes
  # Use centered genotypes to create `K` kinship matrix
  K = tcrossprod(X_centered) / ncol(X_centered)
  # Make rownames and colnames of `K` the randomly sampled elements from `Plots`
  rownames(K) = colnames(K) = data$Plot
  # Calculate the spatial kernel
  field = data[,c('Row','Col')] # Pull out `Row` and `Col` columns
  dists = as.matrix(dist(field)) # Compute the distances 
  h = median(dists) # Calculate default tuning parameter `h`
  K_plot = KRLS::gausskernel(field,h^2/2); diag(K_plot)=1 # Compute the NxN distance matrix with pairwise with pairwise differences between rows as measured by a Gaussian Kernel
  rownames(K_plot) = colnames(K_plot) = data$Plot
  # Create `test_formula`
  if (is.null(covariates)){
    TEST_FORMULA = "~1"
  } else if (!is.null(covariates)){
    TEST_FORMULA = paste("~1 +", paste(covariates, collapse = " + "))
  }
  TEST_FORMULA = as.formula(TEST_FORMULA)
  # Run gwas
  gwas = GridLMM::GridLMM_GWAS(
    formula = y~1 + (1|Geno) + (1|Plot), # the same error model is used for each marker. It is specified similarly to lmer
    test_formula = TEST_FORMULA, # this is the model for each marker. ~1 means an intercept for the marker. ~1 + cov means an intercept plus a slope on `cov` for each marker
    reduced_formula = ~0, # This is the null model for each test. ~0 means just the error model. ~1 means the null includes the intercept of the marker, but not anything additional
    data = data, # The dataframe to look for terms from the 3 models
    weights = NULL, # optional observation-specific weights
    X = X, # The matrix of markers. Note: This can be of dimension n_g x p, where n_g is the number of unique genotypes.
    X_ID = 'Geno', # The column of the data that identifies each genotype. Each level of data$Geno should match a rowname of X
    h2_start = NULL, # An optional vector of h2s to use as starting values for each random effect in the model. If NULL, will be calculated from the error model using GridLMM_ML
    h2_step = 0.01, # step size per random effect for testing alternate values of h2
    max_steps = 100, # maximum number of steps of size h2_step to take from h2_start
    X_map = map, # Optional. The marker positions.
    relmat = list(Plot = K), # A list of Kernel matrices for the random effects. If X_ID (here Geno) is not included in this list, then it is calculated as tcrossprod(Xc)/ncol(Xc) where Xc is the centered (and optionally scaled) X. If any random effects are described in `error_model` but not provided here, the Kernel is assumed to be the identity matrix
    centerX = TRUE, # Should the markers be centered when calculating the GRM (only will be done if needed for calculating the GRM),
    scaleX = FALSE, # Should the markers be scaled to have constant variance when calculating the GRM?
    fillNAX = FALSE, # Should missing marker data be filled in with the mean allele frequency?
    method = 'REML', # REML = Wald test, ML = LRT, BF = calculate Bayes factors
    mc.cores = my_detectCores(), # How many cores should be used for parallel processing. Unless X is large, tends to actually be faster with mc.cores = 1
    verbose = FALSE # Should progress be printed to the screen?
  )
  return(gwas)
}

########################
# Generic functions
########################

clean_gwas_res = function(gwas_results, bin_length, chr_lens){
  gwas_results$results %>% 
    dplyr::left_join(med_chr_lens, by = c("Chr" = "chr")) %>% 
    # add x-coord
    dplyr::mutate(X_COORD = pos + TOT) %>% 
    # change column names
    dplyr::rename(CHROM = Chr, BIN_START = pos) %>% 
    # add BIN_END
    dplyr::mutate(BIN_END = BIN_START + bin_length - 1) %>% 
    # add locus
    dplyr::mutate(LOCUS = paste(CHROM, BIN_START, sep = ":")) 
}

plot_man = function(df, site_filter, phenotype, bin_length, gwas_pal, size = 0.5, alpha = 0.5, med_chr_lens, sig_level = NULL){
  # Create palette
  pal = rep_len(gwas_pal, length.out = nrow(med_chr_lens))
  names(pal) = med_chr_lens$chr
  
  df = df %>% 
    # create `COLOUR` vector
    dplyr::mutate(COLOUR = dplyr::case_when(!is.null(sig_level) & p_value_REML < sig_level ~ gwas_pal[1],
                                            gtools::even(CHROM) ~ gwas_pal[2],
                                            gtools::odd(CHROM) ~ gwas_pal[3])) %>% 
    dplyr::mutate(CHROM = factor(CHROM, levels = med_chr_lens$chr)) 
  
  out_plot = df %>% 
    ggplot(aes(x = X_COORD,
               y = -log10(p_value_REML),
               label = BIN_START,
               label2 = BIN_END)) + 
    geom_point(colour = df$COLOUR,
               size = size,
               alpha = alpha) +
    #scale_color_manual(values = gwas_pal) +
    scale_x_continuous(breaks = med_chr_lens$MID_TOT, 
                       labels = med_chr_lens$chr) +
    theme_bw() +
    theme(panel.grid.major.x = element_blank(),
          panel.grid.minor.x = element_blank()
    ) +
    guides(colour = "none") +
    ggtitle(paste("Site filter: ", site_filter, "\nPhenotype: ", phenotype, "\nBin length: ",  bin_length, sep = "")) +
    xlab("Chromosome") +
    ylab("-log10(p-value)") + 
    geom_hline(yintercept = -log10(sig_level), colour = "#60D394", linetype = "dashed")
  
  return(out_plot)
  
}

plot_int_man = function(df, phenotype, bin_length, gwas_pal, size = 0.5, alpha = 0.5, med_chr_lens, sig_line = NULL){
  # Create palette
  pal = rep_len(gwas_pal, length.out = nrow(med_chr_lens))
  names(pal) = med_chr_lens$chr
  
  # Create plot
  p = df %>% 
    dplyr::mutate(CHROM = factor(CHROM, levels = med_chr_lens$chr)) %>% 
    ggplot(aes(x = X_COORD,
               y = -log10(p_value_REML),
               colour = CHROM,
               label = BIN_START,
               label2 = BIN_END)) + 
    geom_point(size = size,
               alpha = alpha) +
    scale_color_manual(values = pal) +
    scale_x_continuous(breaks = med_chr_lens$MID_TOT, 
                       labels = med_chr_lens$chr) +
    theme_bw() +
    theme(panel.grid.major.x = element_blank(),
          panel.grid.minor.x = element_blank()
    ) +
    guides(colour = "none") +
    ggtitle(paste("Phenotype: ", phenotype, "\nBin length: ",  bin_length, sep = "")) +
    xlab("Chromosome") +
    ylab("-log10(p-value)") + 
    geom_hline(yintercept = sig_line, colour = "#1effbc", linetype = "dashed") 
  
  ggplotly(p, tooltip = c("CHROM", "BIN_START", "BIN_END"))
}

########################
# Plotting parameters
########################

gwas_pal = c("#2B2D42", "#F7B267", "#F25C54")
names(gwas_pal) = c("target", "even chr", "odd chr")
significance_line = 3.6
suggestive_line = 2.9

# Intercept
intercept_pal = c("#EF476F", "#8D99AE", "#2b2d42")
names(intercept_pal) = c("target", "even chr", "odd chr")

# Mean
mean_pal = c("#D81E5B", "#8AA399", "#084C61")
names(mean_pal) = c("target", "even chr", "odd chr")

# PSM
unsegmented_psm_area_pal = c("#E59500", "#D9D0DE", "#401F3E")
names(mean_pal) = c("target", "even chr", "odd chr")

########################
# HdrR chromosome data
########################
# Get chromosome lengths
med_chr_lens = read.table(here::here("data",
                                     "Oryzias_latipes.ASM223467v1.dna.toplevel.fa_chr_counts.txt"),
                          col.names = c("chr", "end"))
# Add start
med_chr_lens$start = 1
# Reorder
med_chr_lens = med_chr_lens %>% 
  dplyr::select(chr, start, end) %>% 
  # remove MT
  dplyr::filter(chr != "MT") %>% 
  # convert to integer
  dplyr::mutate(chr = as.integer(chr)) %>% 
  # Add cumulative bases
  dplyr::mutate(CUMSUM = cumsum(end),
                TOT = CUMSUM - end) %>% 
  # Add midpoint for each chr
  dplyr::mutate(MID_TOT = TOT + (end / 2))

