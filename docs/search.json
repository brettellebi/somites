[{"path":"index.html","id":"about","chapter":"1 About","heading":"1 About","text":"book sets analysis somite development periods, Ali Ahmed Seleit Aulehla Group EMBL Heidelberg.","code":""},{"path":"alignment-of-f0-and-f2-generations.html","id":"alignment-of-f0-and-f2-generations","chapter":"2 Alignment of F0 and F2 generations","heading":"2 Alignment of F0 and F2 generations","text":"code used process data using Snakemake1 can found :Config:https://github.com/brettellebi/somites/tree/master/configConfig:https://github.com/brettellebi/somites/tree/master/configWorkflow:https://github.com/brettellebi/somites/tree/master/workflowWorkflow:https://github.com/brettellebi/somites/tree/master/workflow","code":""},{"path":"homozygosity-of-f0-cab-and-kaga.html","id":"homozygosity-of-f0-cab-and-kaga","chapter":"3 Homozygosity of F0 Cab and Kaga","heading":"3 Homozygosity of F0 Cab and Kaga","text":"","code":""},{"path":"homozygosity-of-f0-cab-and-kaga.html","id":"read-in-total-medaka-genome-count","chapter":"3 Homozygosity of F0 Cab and Kaga","heading":"3.1 Read in total medaka genome count","text":"Make custom chromosome scaffold","code":"\n# Get chromosome lengths\nmed_chr_lens = read.table(here::here(\"data\",\n                                     \"Oryzias_latipes.ASM223467v1.dna.toplevel.fa_chr_counts.txt\"),\n                          col.names = c(\"chr\", \"end\"))\n# Add start\nmed_chr_lens$start = 1\n# Reorder\nmed_chr_lens = med_chr_lens %>% \n  dplyr::select(chr, start, end) %>% \n  # remove MT\n  dplyr::filter(chr != \"MT\")\n\n# Total HdrR sequence length\ntotal_hdrr_bases = sum(med_chr_lens$end)\n##Create custom genome \nmed_genome = regioneR::toGRanges(med_chr_lens)"},{"path":"homozygosity-of-f0-cab-and-kaga.html","id":"read-in-data","chapter":"3 Homozygosity of F0 Cab and Kaga","heading":"3.2 Read in data","text":"","code":"\nin_dir = \"/nfs/research/birney/users/ian/somites/recombination_blocks\"\n\nin_files = list.files(in_dir, pattern = \"20210803_hmm_output_F0\", full.names = T)\n\n# Read into list\nck_list = purrr::map(in_files, function(FILE){\n  out = readr::read_tsv(FILE,\n                        col_types = \"ciiidii\")\n})\n# Set names as bin length\nnames(ck_list) = basename(in_files) %>% \n  stringr::str_split(\"_\", simplify = T) %>% \n  subset(select = 6) %>% \n  stringr::str_remove(\".txt\")\n# Reorder\nck_list = ck_list[order(as.numeric(names(ck_list)))]\n\ncounter = 0\nck_list = purrr::map(ck_list, function(data){\n  counter <<- counter + 1\n  # set bin length\n  bin_length = as.numeric(names(ck_list)[counter])\n  # add bin start and end coordinates\n  df = data %>% \n    dplyr::mutate(LANE = sample %>%\n                    stringr::str_split(\"/\", simplify = T) %>% \n                    subset(select = 10),\n                  BIN_LENGTH = bin_length,\n                  BIN_START = (bin - 1) * bin_length + 1,\n                  BIN_END = bin * bin_length,\n                  BIN_LENGTH_KB = BIN_LENGTH / 1e3,\n                  READS_PER_BIN = mat + pat)\n  return(df)\n})\n\n# Recode `ck_list$state` so that 0,1,2 corresponds to HOM_REF, HET, HOM_ALT \nck_list = purrr::map(ck_list, function(df){\n  df = df %>% \n    dplyr::mutate(state = dplyr::recode(state,\n                                        `0` = 2,\n                                        `1` = 1,\n                                        `2` = 0))\n})"},{"path":"homozygosity-of-f0-cab-and-kaga.html","id":"get-total-number-of-bases-covered-by-each-state","chapter":"3 Homozygosity of F0 Cab and Kaga","heading":"3.2.1 Get total number of bases covered by each state","text":"Plot","code":"\n# Take 5kb DF\ndf = ck_list$`5000`\n\n# Set states to loop over\nstates = 0:2\nnames(states) = states\n\n# Run loop over each LANE\n\nbase_cov_df = df %>% \n  split(., f = .$LANE) %>% \n  purrr::map(., function(LANE){\n    # convert to ranges object\n    lane_ranges = GenomicRanges::makeGRangesFromDataFrame(LANE,\n                                                          keep.extra.columns = T,\n                                                          ignore.strand = T,\n                                                          seqnames.field = \"chr\", \n                                                          start.field = \"BIN_START\",\n                                                          end.field = \"BIN_END\")\n    # get total bases covered by each state\n    purrr::map_dfr(states, function(STATE){\n      lane_ranges[lane_ranges$state == STATE] %>% \n        # merge contiguous ranges\n        GenomicRanges::reduce(.) %>% \n        # get width of ranges\n        width(.) %>% \n        # get total bases covered\n        sum(.) %>% \n        # coerce into data frame\n        data.frame(\"BASES_COVERED\" = .)\n      }, .id = \"STATE\") %>% \n        # add FREQ column\n        dplyr::mutate(FREQ = BASES_COVERED / total_hdrr_bases) %>% \n        # add UNCLASSIFIED row\n        tibble::add_row(STATE = \"UNCLASSIFIED\", \n                        BASES_COVERED = total_hdrr_bases - sum(.$BASES_COVERED),\n                        FREQ = (total_hdrr_bases - sum(.$BASES_COVERED)) / total_hdrr_bases)\n    }\n  ) %>% \n  dplyr::bind_rows(.id = \"LANE\")\n# Plot\nck_prop_plot = base_cov_df %>% \n  dplyr::mutate(STATE = factor(STATE, levels = c(0,1,2, \"UNCLASSIFIED\")),\n                STATE_RECODE = dplyr::recode(STATE,\n                                             `0` = \"HOM REF (HdrR)\",\n                                             `1` = \"HET\",\n                                             `2` = \"HOM ALT\",\n                                             \"UNCLASSIFIED\" = \"Unclassified\")) %>% \n  # plot\n  ggplot(aes(STATE_RECODE, FREQ, colour = STATE, fill = STATE)) +\n    geom_col() +\n    facet_grid(cols = vars(LANE)) +\n    theme_bw() +\n    scale_colour_manual(values = pal_ck_1_lines) +\n    scale_fill_manual(values = pal_ck_1) +\n    guides(colour = \"none\", fill = \"none\") +\n    xlab(\"Genotype\") +\n    ylab(\"Proportion of reference bases covered\")\n\nck_prop_plot\n\n# Interactive version\nggplotly(ck_prop_plot)"},{"path":"homozygosity-of-f0-cab-and-kaga.html","id":"karyoplot","chapter":"3 Homozygosity of F0 Cab and Kaga","heading":"3.3 Karyoplot","text":"Extract y cutoff points yPlot Karyoplots\nFigure 3.1: Bin length: 5 kb\n","code":"\nbb_list_ck = purrr::map(ck_list, function(df){\n  # loop over different bin lengths\n  block_bounds_list = df %>% \n    # loop over LANE\n    split(., f = .$LANE) %>% \n    purrr::map(., function(LANE){\n      # loop over CHR\n      LANE %>% \n        split(., f = .$chr) %>% \n        purrr::map(., function(CHR){\n          # Get lengths of each contiguous state\n          cont_len = rle(CHR$state)\n          \n          # Get cumulative sum of those lengths\n          cum_blocks = cumsum(cont_len$lengths)\n          \n          # Get rows that correspond to block changes\n          block_bounds = CHR[cum_blocks, ] %>% \n            # Add end of previous black\n            dplyr::mutate(END_PREV = dplyr::lag(BIN_END)) %>% \n            # Replace the NA in the first row with `1`\n            dplyr::mutate(END_PREV = tidyr::replace_na(END_PREV, 1)) %>% \n            # Add colour\n            dplyr::mutate(COLOUR = dplyr::recode(state,\n                                                 !!!pal_ck_1[-which(names(pal_ck_1) == \"UNCLASSIFIED\")])) \n          \n        }) %>% \n            dplyr::bind_rows()\n      \n  })\n})\nlc_list_ck = purrr::map(bb_list_ck, function(block_bounds_list){\n  lane_cutoffs = cut(0:1, breaks = length(block_bounds_list)) %>% \n    levels(.) %>% \n    data.frame(lower = as.numeric( sub(\"\\\\((.+),.*\", \"\\\\1\", .) ),\n               upper = as.numeric( sub(\"[^,]*,([^]]*)\\\\]\", \"\\\\1\", .) )) %>% \n    dplyr::arrange(dplyr::desc(lower))\n  return(lane_cutoffs)\n})\ncounter_A = 0\npurrr::map(bb_list_ck, function(block_bounds_list){\n  counter_A <<- counter_A + 1\n  # set file name\n  file_name = paste(\"20210803_ck_karyoplot_\", names(bb_list)[counter_A], \".png\", sep = \"\")\n  file_out = here::here(\"docs/plots\", file_name)\n  \n  # Get lane cutoffs\n  lane_cutoffs = lc_list_ck[[counter_A]]\n  \n  png(file=file_out,\n      width=13000,\n      height=3000,\n      units = \"px\",\n      res = 300)\n  \n  # Plot ideogram\n  kp = karyoploteR::plotKaryotype(med_genome, plot.type = 5)\n  # Add data background\n  #karyoploteR::kpDataBackground(kp, r0=0, r1 = 1, color = \"white\")\n  \n  # Add rectangles in loop\n  counter_B = 0\n  purrr::map(block_bounds_list, function(LANE){\n    # Add to counter_B\n    counter_B <<- counter_B + 1\n    # Add rectangles\n    karyoploteR::kpRect(kp,\n                        chr = LANE$chr,\n                        x0 = LANE$END_PREV,\n                        x1 = LANE$BIN_END,\n                        y0 = lane_cutoffs[counter_B, ] %>% \n                          dplyr::pull(lower),\n                        y1 = lane_cutoffs[counter_B, ] %>% \n                          dplyr::pull(upper),\n                        col = LANE$COLOUR,\n                        border = NA)\n    # Add axis label\n    karyoploteR::kpAddLabels(kp, labels = unique(LANE$LANE),\n                             r0 = lane_cutoffs[counter_B, ] %>% \n                               dplyr::pull(lower),\n                             r1 = lane_cutoffs[counter_B, ] %>% \n                               dplyr::pull(upper),\n                             cex = 0.5)\n  })\n  \n  \n  dev.off()  \n})\nknitr::include_graphics(here::here(\"book/plots/20210803_ck_karyoplot_5000.png\"))"},{"path":"homozygosity-of-f0-cab-and-kaga.html","id":"update","chapter":"3 Homozygosity of F0 Cab and Kaga","heading":"3.4 20211110 update","text":"Changes:Used homozgygous-divergent Cab-Kaga sites instead sites F0 VCFFiltered reads overlapped repeat regions","code":""},{"path":"homozygosity-of-f0-cab-and-kaga.html","id":"read-in-data-1","chapter":"3 Homozygosity of F0 Cab and Kaga","heading":"3.4.1 Read in data","text":"","code":"\nin_dir = \"/nfs/research/birney/users/ian/somites/recombination_blocks/F0/no_repeat_reads\"\n\nin_files = list.files(in_dir, full.names = T)\n\n# Read into list\nck_list = purrr::map(in_files, function(FILE){\n  out = readr::read_tsv(FILE,\n                        col_types = \"ciiidii\")\n})\n# Set names as bin length\nnames(ck_list) = basename(in_files) %>%\n  stringr::str_remove(\".txt\")\n# Reorder\nck_list = ck_list[order(as.numeric(names(ck_list)))]\n\ncounter = 0\nck_list = purrr::map(ck_list, function(data){\n  counter <<- counter + 1\n  # set bin length\n  bin_length = as.numeric(names(ck_list)[counter])\n  # add bin start and end coordinates\n  df = data %>% \n    dplyr::mutate(LANE = sample %>%\n                    basename() %>% \n                    stringr::str_remove(\".txt\"),\n                  BIN_LENGTH = bin_length,\n                  BIN_START = (bin - 1) * bin_length + 1,\n                  BIN_END = bin * bin_length,\n                  BIN_LENGTH_KB = BIN_LENGTH / 1e3,\n                  READS_PER_BIN = mat + pat)\n  return(df)\n})\n\n# Recode `ck_list$state` so that 0,1,2 corresponds to Cab, Het, Kaga \nck_list = purrr::map(ck_list, function(df){\n  df = df %>% \n    dplyr::mutate(state = dplyr::recode(state,\n                                        `0` = 2,\n                                        `1` = 1,\n                                        `2` = 0))\n})"},{"path":"homozygosity-of-f0-cab-and-kaga.html","id":"get-total-number-of-bases-covered-by-each-state-1","chapter":"3 Homozygosity of F0 Cab and Kaga","heading":"3.4.2 Get total number of bases covered by each state","text":"Plot","code":"\n# Take 5kb DF\ndf = ck_list$`5000`\n\n# Set states to loop over\nstates = 0:2 ; names(states) = states\n\n# Run loop over each LANE\n\nbase_cov_df = df %>% \n  split(., f = .$LANE) %>% \n  purrr::map(., function(LANE){\n    # convert to ranges object\n    lane_ranges = GenomicRanges::makeGRangesFromDataFrame(LANE,\n                                                          keep.extra.columns = T,\n                                                          ignore.strand = T,\n                                                          seqnames.field = \"chr\", \n                                                          start.field = \"BIN_START\",\n                                                          end.field = \"BIN_END\")\n    # get total bases covered by each state\n    purrr::map_dfr(states, function(STATE){\n      lane_ranges[lane_ranges$state == STATE] %>% \n        # merge contiguous ranges\n        GenomicRanges::reduce(.) %>% \n        # get width of ranges\n        width(.) %>% \n        # get total bases covered\n        sum(.) %>% \n        # coerce into data frame\n        data.frame(\"BASES_COVERED\" = .)\n      }, .id = \"STATE\") %>% \n        # add FREQ column\n        dplyr::mutate(FREQ = BASES_COVERED / total_hdrr_bases) %>% \n        # add UNCLASSIFIED row\n        tibble::add_row(STATE = \"UNCLASSIFIED\", \n                        BASES_COVERED = total_hdrr_bases - sum(.$BASES_COVERED),\n                        FREQ = (total_hdrr_bases - sum(.$BASES_COVERED)) / total_hdrr_bases)\n    }\n  ) %>% \n  dplyr::bind_rows(.id = \"LANE\")\n# Plot\nck_prop_plot = base_cov_df %>% \n  dplyr::mutate(STATE = factor(STATE, levels = c(0,1,2, \"UNCLASSIFIED\")),\n                STATE_RECODE = dplyr::recode(STATE,\n                                             `0` = \"Homozygous Cab\",\n                                             `1` = \"Heterozygous\",\n                                             `2` = \"Homozygous Kaga\",\n                                             \"UNCLASSIFIED\" = \"Unclassified\")) %>% \n  # plot\n  ggplot(aes(STATE_RECODE, FREQ, colour = STATE, fill = STATE)) +\n    geom_col() +\n    facet_grid(cols = vars(LANE)) +\n    theme_bw(base_size = 9) +\n    scale_colour_manual(values = pal_ck_1_lines) +\n    scale_fill_manual(values = pal_ck_1) +\n    guides(colour = \"none\", fill = \"none\") +\n    xlab(\"Genotype\") +\n    ylab(\"Proportion of reference bases covered\")\n\nck_prop_plot\n\n# Interactive version\nggplotly(ck_prop_plot)"},{"path":"homozygosity-of-f0-cab-and-kaga.html","id":"karyoplot-1","chapter":"3 Homozygosity of F0 Cab and Kaga","heading":"3.4.3 Karyoplot","text":"Extract y cutoff points yPlot Karyoplots\nFigure 3.2: Bin length: 5 kb\n","code":"\nbb_list_ck = purrr::map(ck_list, function(df){\n  # loop over different bin lengths\n  block_bounds_list = df %>% \n    # loop over LANE\n    split(., f = .$LANE) %>% \n    purrr::map(., function(LANE){\n      # loop over CHR\n      LANE %>% \n        split(., f = .$chr) %>% \n        purrr::map(., function(CHR){\n          # Get lengths of each contiguous state\n          cont_len = rle(CHR$state)\n          \n          # Get cumulative sum of those lengths\n          cum_blocks = cumsum(cont_len$lengths)\n          \n          # Get rows that correspond to block changes\n          block_bounds = CHR[cum_blocks, ] %>% \n            # Add end of previous black\n            dplyr::mutate(END_PREV = dplyr::lag(BIN_END)) %>% \n            # Replace the NA in the first row with `1`\n            dplyr::mutate(END_PREV = tidyr::replace_na(END_PREV, 1)) %>% \n            # Add colour\n            dplyr::mutate(COLOUR = dplyr::recode(state,\n                                                 !!!pal_ck_1[-which(names(pal_ck_1) == \"UNCLASSIFIED\")])) \n          \n        }) %>% \n            dplyr::bind_rows()\n      \n  })\n})\nlc_list_ck = purrr::map(bb_list_ck, function(block_bounds_list){\n  lane_cutoffs = cut(0:1, breaks = length(block_bounds_list)) %>% \n    levels(.) %>% \n    data.frame(lower = as.numeric( sub(\"\\\\((.+),.*\", \"\\\\1\", .) ),\n               upper = as.numeric( sub(\"[^,]*,([^]]*)\\\\]\", \"\\\\1\", .) )) %>% \n    dplyr::arrange(dplyr::desc(lower))\n  return(lane_cutoffs)\n})\ncounter_A = 0\npurrr::map(bb_list_ck, function(block_bounds_list){\n  counter_A <<- counter_A + 1\n  # set file name\n  file_name = paste(\"20211110_ck_karyoplot_\", names(bb_list_ck)[counter_A], \".png\", sep = \"\")\n  file_out = here::here(\"book/plots\", file_name)\n  \n  # Get lane cutoffs\n  lane_cutoffs = lc_list_ck[[counter_A]]\n  \n  png(file=file_out,\n      width=13000,\n      height=3000,\n      units = \"px\",\n      res = 300)\n  \n  # Plot ideogram\n  kp = karyoploteR::plotKaryotype(med_genome, plot.type = 5)\n  # Add data background\n  #karyoploteR::kpDataBackground(kp, r0=0, r1 = 1, color = \"white\")\n  \n  # Add rectangles in loop\n  counter_B = 0\n  purrr::map(block_bounds_list, function(LANE){\n    # Add to counter_B\n    counter_B <<- counter_B + 1\n    # Add rectangles\n    karyoploteR::kpRect(kp,\n                        chr = LANE$chr,\n                        x0 = LANE$END_PREV,\n                        x1 = LANE$BIN_END,\n                        y0 = lane_cutoffs[counter_B, ] %>% \n                          dplyr::pull(lower),\n                        y1 = lane_cutoffs[counter_B, ] %>% \n                          dplyr::pull(upper),\n                        col = LANE$COLOUR,\n                        border = NA)\n    # Add axis label\n    karyoploteR::kpAddLabels(kp, labels = unique(LANE$LANE),\n                             r0 = lane_cutoffs[counter_B, ] %>% \n                               dplyr::pull(lower),\n                             r1 = lane_cutoffs[counter_B, ] %>% \n                               dplyr::pull(upper),\n                             cex = 0.5)\n  })\n  \n  \n  dev.off()  \n})\nknitr::include_graphics(here::here(\"book/plots/20211110_ck_karyoplot_5000.png\"))"},{"path":"homozygosity-of-f0-cab-and-kaga.html","id":"without-filling-in-empty-blocks","chapter":"3 Homozygosity of F0 Cab and Kaga","heading":"3.4.4 Without filling in empty blocks","text":"Plot Karyoplots\nFigure 3.3: Bin length: 5 kb\n","code":"\ncounter = 0\nbb_list_ck_wunc = purrr::map(ck_list, function(df){\n  counter <<- counter + 1\n  \n  BIN_LENGTH = names(ck_list)[counter] %>% \n    as.numeric()\n  # loop over different bin lengths\n  block_bounds_list = df %>% \n    # loop over LANE\n    split(., f = .$LANE) %>% \n    purrr::map(., function(LANE){\n    \n      STRAIN = unique(LANE$LANE)\n      # Create list of possible bins\n      poss_bins = purrr::map(med_chr_lens$chr, function(CHR){\n        # Get chr end\n        CHR_END = med_chr_lens %>% \n          dplyr::filter(chr == CHR) %>% \n          dplyr::pull(end)\n          as.numeric()\n        # Get bin starts\n        out = tibble::tibble(chr = as.numeric(CHR),\n                             BIN_START = seq(from = 1, to = CHR_END, by = BIN_LENGTH),\n                             BIN_END = BIN_START + BIN_LENGTH - 1\n        )\n        # Adjust final bin end \n        out[nrow(out), \"BIN_END\"] = CHR_END\n        \n        return(out)\n      }) %>% \n        dplyr::bind_rows()\n    \n      \n      # Bind DF\n      new_df = dplyr::left_join(poss_bins,\n                                LANE %>% \n                                  dplyr::select(chr, BIN_START, BIN_END, state),\n                                by = c(\"chr\", \"BIN_START\", \"BIN_END\")) %>% \n        # replace NAs with `UNCLASSIFIED`\n        dplyr::mutate(state = state %>% \n                        tidyr::replace_na(\"UNCLASSIFIED\"),\n                      # add STRAIN\n                      LANE = STRAIN) %>% \n        # add COLOUR\n        dplyr::mutate(COLOUR = dplyr::recode(state,\n                                             !!!pal_ck_1))\n    \n              \n    })\n})\ncounter_A = 0\npurrr::map(bb_list_ck_wunc, function(block_bounds_list){\n  counter_A <<- counter_A + 1\n  # set file name\n  file_name = paste(\"20211110_ck_karyoplot_wimiss_\", names(bb_list_ck_wunc)[counter_A], \".png\", sep = \"\")\n  file_out = here::here(\"book/plots\", file_name)\n  \n  # Get lane cutoffs\n  lane_cutoffs = lc_list_ck[[counter_A]]\n  \n  png(file=file_out,\n      width=13000,\n      height=3000,\n      units = \"px\",\n      res = 300)\n  \n  # Plot ideogram\n  kp = karyoploteR::plotKaryotype(med_genome, plot.type = 5)\n  # Add data background\n  #karyoploteR::kpDataBackground(kp, r0=0, r1 = 1, color = \"white\")\n  \n  # Add rectangles in loop\n  counter_B = 0\n  purrr::map(block_bounds_list, function(LANE){\n    # Add to counter_B\n    counter_B <<- counter_B + 1\n    # Add rectangles\n    karyoploteR::kpRect(kp,\n                        chr = LANE$chr,\n                        x0 = LANE$BIN_START,\n                        x1 = LANE$BIN_END,\n                        y0 = lane_cutoffs[counter_B, ] %>% \n                          dplyr::pull(lower),\n                        y1 = lane_cutoffs[counter_B, ] %>% \n                          dplyr::pull(upper),\n                        col = LANE$COLOUR,\n                        border = NA)\n    # Add axis label\n    karyoploteR::kpAddLabels(kp, labels = unique(LANE$LANE),\n                             r0 = lane_cutoffs[counter_B, ] %>% \n                               dplyr::pull(lower),\n                             r1 = lane_cutoffs[counter_B, ] %>% \n                               dplyr::pull(upper),\n                             cex = 3.5)\n  })\n  \n  \n  dev.off()  \n})\nknitr::include_graphics(here::here(\"book/plots/20211110_ck_karyoplot_wimiss_5000.png\"))"},{"path":"f2-recombination-blocks-old.html","id":"f2-recombination-blocks-old","chapter":"4 F2 recombination blocks (old)","heading":"4 F2 recombination blocks (old)","text":"","code":"\nlibrary(here)\nsource(here::here(\"book/source/03-F2_recombination.R\"))"},{"path":"f2-recombination-blocks-old.html","id":"read-in-data-2","chapter":"4 F2 recombination blocks (old)","heading":"4.1 Read in data","text":"","code":"\nin_dir = \"/nfs/research/birney/users/ian/somites/recombination_blocks/20211027\"\n\nin_files = list.files(in_dir, pattern = \"F2_\", full.names = T)\n\n##Read into list\ndata_list = purrr::map(in_files, function(FILE){\n  out = readr::read_tsv(FILE,\n                        col_types = \"ciiidii\")\n})\n##Set names as bin length\nnames(data_list) = basename(in_files) %>% \n  stringr::str_split(\"_\", simplify = T) %>% \n  subset(select = 2) %>% \n  stringr::str_remove(\".txt\")\n##Reorder\ndata_list = data_list[order(as.numeric(names(data_list)))]\n\ncounter = 0\ndf_list = purrr::map(data_list, function(data){\n  counter <<- counter + 1\n  # set bin length\n  bin_length = as.numeric(names(data_list)[counter])\n  # add bin start and end coordinates\n  df = data %>% \n    dplyr::mutate(LANE = basename(sample) %>% \n                    stringr::str_remove(\".txt\") %>% \n                    as.numeric(.),\n                  BIN_LENGTH = bin_length,\n                  BIN_START = (bin - 1) * bin_length + 1,\n                  BIN_END = bin * bin_length,\n                  BIN_LENGTH_KB = BIN_LENGTH / 1e3,\n                  READS_PER_BIN = mat + pat)\n  return(df)\n})"},{"path":"f2-recombination-blocks-old.html","id":"examine-relationship-between-ratio-and-state","chapter":"4 F2 recombination blocks (old)","heading":"4.2 Examine relationship between ratio and state","text":"determine state associated parental strain.pipeline, set Cab F0_1 Kaga F0_2.ratio = mat / (mat + pat), mat = Cab pat = Kaga.Plot ratio stateThis shows state 0 associated low ratio Cab Kaga, therefore call Kaga.\nVice versa state 2 Cab.","code":"\nhead(df_list$`5000`) %>% \n  DT::datatable(.)\ndf_list$`5000` %>%\n  dplyr::mutate(state = factor(state, levels = 0:2)) %>% \n  dplyr::slice_sample(n = 1e6) %>% \n  ggplot() +\n    geom_boxplot(aes(state, ratio)) +\n    guides(colour = \"none\") +\n    theme_bw()\n##Save\nggsave(here::here(\"book/plots/20211027_ratio_v_state.png\"),\n       device = \"png\",\n       width = 8,\n       height = 5,\n       units = \"in\",\n       dpi = 400)\nknitr::include_graphics(here::here(\"book/plots/20211027_ratio_v_state.png\"))"},{"path":"f2-recombination-blocks-old.html","id":"recode-state-to-put-in-correct-order","chapter":"4 F2 recombination blocks (old)","heading":"4.2.1 Recode state to put in correct order","text":"","code":"\ndf_list = purrr::map(df_list, function(df){\n  df = df %>% \n    dplyr::mutate(state = dplyr::recode(state,\n                                        `0` = 2,\n                                        `1` = 1,\n                                        `2` = 0))\n})"},{"path":"f2-recombination-blocks-old.html","id":"read-counts-per-bin","chapter":"4 F2 recombination blocks (old)","heading":"4.3 Read counts per bin","text":"","code":"\n##How many bins in each data frame? \npurrr::map_int(df_list, nrow)\n#>     5000    10000    15000    20000 \n#> 32250155 19648391 14329553 11322702\n\n##Plot\ndf_list %>% \n  dplyr::bind_rows() %>% \n  dplyr::slice_sample(n = 1e5) %>% \n  dplyr::mutate(BIN_LENGTH_KB = factor(BIN_LENGTH_KB, levels = unique(BIN_LENGTH_KB)[order(unique(BIN_LENGTH_KB))])) %>% \n  # Plot\n  ggplot(aes(BIN_LENGTH_KB, log10(READS_PER_BIN), fill = BIN_LENGTH_KB)) +\n    geom_boxplot() +\n    theme_bw() +\n    scale_fill_manual(values = c(\"#778DA9\", \"#415A77\", \"#1B263B\", \"#0D1B2A\")) +\n    guides(fill = \"none\")\n#> Warning: Removed 62 rows containing non-finite values\n#> (stat_boxplot)."},{"path":"f2-recombination-blocks-old.html","id":"read-counts-by-proportion-of-kaga","chapter":"4 F2 recombination blocks (old)","heading":"4.4 Read counts by proportion of Kaga","text":"","code":"\ndf_list %>% \n  dplyr::bind_rows() %>% \n  dplyr::slice_sample(n = 1e5) %>% \n  dplyr::mutate(PROP_KAGA = pat / READS_PER_BIN ) %>% \n  # Plot\n  ggplot(aes(READS_PER_BIN, PROP_KAGA)) +\n    geom_point(alpha = 0.2) +\n    theme_bw() +\n    facet_grid(cols = vars(BIN_LENGTH)) +\n##   scale_colour_manual(values = c(\"#778DA9\", \"#415A77\", \"#1B263B\", \"#0D1B2A\")) +\n    guides(fill = \"none\")\n#> Warning: Removed 77 rows containing missing values\n#> (geom_point).\n\n##Limit to bins with 0-100 reads\ndf_list %>% \n  dplyr::bind_rows() %>% \n  dplyr::slice_sample(n = 1e5) %>% \n  dplyr::mutate(PROP_KAGA = pat / READS_PER_BIN ) %>% \n  # Plot\n  ggplot(aes(READS_PER_BIN, PROP_KAGA)) +\n    geom_point(alpha = 0.2) +\n    theme_bw() +\n    facet_grid(cols = vars(BIN_LENGTH)) +\n##   scale_colour_manual(values = c(\"#778DA9\", \"#415A77\", \"#1B263B\", \"#0D1B2A\")) +\n    guides(fill = \"none\") +\n    xlim(0,100)\n#> Warning: Removed 21377 rows containing missing values\n#> (geom_point)."},{"path":"f2-recombination-blocks-old.html","id":"proportion-of-genome-and-sites-called-as-a-given-state","chapter":"4 F2 recombination blocks (old)","heading":"4.5 Proportion of genome and sites called as a given state","text":"","code":""},{"path":"f2-recombination-blocks-old.html","id":"proportion-of-genome-covered-by-each-state","chapter":"4 F2 recombination blocks (old)","heading":"4.5.1 Proportion of genome covered by each state","text":"","code":""},{"path":"f2-recombination-blocks-old.html","id":"read-in-total-medaka-genome-count-1","chapter":"4 F2 recombination blocks (old)","heading":"4.5.1.1 Read in total medaka genome count","text":"","code":"\n##Get chromosome lengths\nmed_chr_lens = read.table(here::here(\"data\",\n                                     \"Oryzias_latipes.ASM223467v1.dna.toplevel.fa_chr_counts.txt\"),\n                          col.names = c(\"chr\", \"end\"))\n##Add start\nmed_chr_lens$start = 1\n##Reorder\nmed_chr_lens = med_chr_lens %>% \n  dplyr::select(chr, start, end) %>% \n  # remove MT\n  dplyr::filter(chr != \"MT\")\n\n##Total HdrR sequence length\ntotal_hdrr_bases = sum(med_chr_lens$end)"},{"path":"f2-recombination-blocks-old.html","id":"get-total-number-of-bases-covered-by-each-state-2","chapter":"4 F2 recombination blocks (old)","heading":"4.5.1.2 Get total number of bases covered by each state","text":"Plot","code":"\n##Take 5kb DF\ndf = df_list$`5000`\n\n##Set states to loop over\nstates = 0:2\nnames(states) = states\n\n##Run loop over each LANE\n\nbase_cov_df = df %>% \n  split(., f = .$LANE) %>% \n  purrr::map(., function(LANE){\n    # convert to ranges object\n    lane_ranges = GenomicRanges::makeGRangesFromDataFrame(LANE,\n                                                          keep.extra.columns = T,\n                                                          ignore.strand = T,\n                                                          seqnames.field = \"chr\", \n                                                          start.field = \"BIN_START\",\n                                                          end.field = \"BIN_END\")\n    # get total bases covered by each state\n    purrr::map_dfr(states, function(STATE){\n      lane_ranges[lane_ranges$state == STATE] %>% \n        # merge contiguous ranges\n        GenomicRanges::reduce(.) %>% \n        # get width of ranges\n        width(.) %>% \n        # get total bases covered\n        sum(.) %>% \n        # coerce into data frame\n        data.frame(\"BASES_COVERED\" = .)\n      }, .id = \"STATE\") %>% \n        # add FREQ column\n        dplyr::mutate(FREQ = BASES_COVERED / total_hdrr_bases) %>% \n        # add UNCLASSIFIED row\n        tibble::add_row(STATE = \"UNCLASSIFIED\", \n                        BASES_COVERED = total_hdrr_bases - sum(.$BASES_COVERED),\n                        FREQ = (total_hdrr_bases - sum(.$BASES_COVERED)) / total_hdrr_bases)\n    }\n  ) %>% \n  dplyr::bind_rows(.id = \"LANE\")\n##Plot\nbase_cov_df %>% \n  dplyr::mutate(STATE = factor(STATE, levels = c(0,1,2, \"UNCLASSIFIED\")),\n                STATE_RECODE = dplyr::recode(STATE,\n                                             `0` = \"Homozygous Cab\",\n                                             `1` = \"Heterozygous\",\n                                             `2` = \"Homozygous Kaga\",\n                                             \"UNCLASSIFIED\" = \"Unclassified\")) %>% \n  # plot\n  ggplot(aes(STATE_RECODE, FREQ, colour = STATE, fill = STATE)) +\n    geom_violin() +\n    geom_boxplot(width = .3) +\n    ggbeeswarm::geom_quasirandom(color=\"#7D8491\", size=0.4, alpha=0.9) +\n    theme_bw() +\n    scale_colour_manual(values = pal_hom_het_2_lines) +\n    scale_fill_manual(values = pal_hom_het_2) +\n    guides(colour = \"none\", fill = \"none\") +\n    xlab(\"Genotype\") +\n    ylab(\"Proportion of reference bases covered\")"},{"path":"f2-recombination-blocks-old.html","id":"by-chromosome","chapter":"4 F2 recombination blocks (old)","heading":"4.5.1.3 By chromosome","text":"Process.Plot","code":"\n##Set states to loop over\nstates = 0:2\nnames(states) = states\n\n##Run loop over each LANE\n\nbase_cov_df_chr = df %>% \n  split(., f = .$LANE) %>% \n    purrr::map(., function(LANE){\n      # convert to ranges object\n      lane_ranges = GenomicRanges::makeGRangesFromDataFrame(LANE,\n                                                            keep.extra.columns = T,\n                                                            ignore.strand = T,\n                                                            seqnames.field = \"chr\", \n                                                            start.field = \"BIN_START\",\n                                                            end.field = \"BIN_END\")\n      # loop over each chromosome\n      purrr::map(med_chr_lens$chr, function(CHR){\n        # get total length of target chromosome\n        target_chr_len = med_chr_lens$end[med_chr_lens$chr == CHR]\n        # get total bases covered by each state per chromosome\n        purrr::map_dfr(states, function(STATE){\n          lane_ranges[lane_ranges$state == STATE & lane_ranges@seqnames == CHR] %>% \n            # merge contiguous ranges\n            GenomicRanges::reduce(.) %>% \n            # get width of ranges\n            width(.) %>% \n            # get total bases covered\n            sum(.) %>% \n            # coerce into data frame\n            data.frame(\"BASES_COVERED\" = .)\n          }, .id = \"STATE\") %>% \n            # add FREQ column\n            dplyr::mutate(FREQ = BASES_COVERED / target_chr_len ) %>% \n            # add UNCLASSIFIED row\n            tibble::add_row(STATE = \"UNCLASSIFIED\", \n                            BASES_COVERED = target_chr_len - sum(.$BASES_COVERED),\n                            FREQ = (target_chr_len - sum(.$BASES_COVERED)) / target_chr_len)\n      }) %>% \n        dplyr::bind_rows(.id = \"CHR\")\n    }\n  ) %>% \n  dplyr::bind_rows(.id = \"LANE\")\nsaveRDS(base_cov_df_chr, here::here(\"data/20211027_base_cov_per_chr.rds\"))\n##Plot\nbase_cov_df_chr %>% \n  dplyr::mutate(STATE = factor(STATE, levels = c(0,1,2, \"UNCLASSIFIED\")),\n                STATE_RECODE = dplyr::recode(STATE,\n                                             `0` = \"Homozygous Cab\",\n                                             `1` = \"Heterozygous\",\n                                             `2` = \"Homozygous Kaga\",\n                                             \"UNCLASSIFIED\" = \"Unclassified\"),\n                CHR = factor(CHR, levels = med_chr_lens$chr)) %>% \n  # plot\n  ggplot(aes(STATE_RECODE, FREQ, colour = STATE, fill = STATE)) +\n    geom_violin() +\n    geom_boxplot(width = .1) +\n    ggbeeswarm::geom_quasirandom(color=\"#7D8491\", size=0.1, alpha=0.7) +\n    theme_bw() +\n    scale_colour_manual(values = pal_hom_het_2_lines) +\n    scale_fill_manual(values = pal_hom_het_2) +\n    guides(colour = \"none\", fill = \"none\") +\n    xlab(\"Genotype\") +\n    ylab(\"Proportion of reference bases covered\") +\n    facet_wrap(~CHR, nrow = 4, ncol = 6) +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1))"},{"path":"f2-recombination-blocks-old.html","id":"proportion-of-sites-covered-by-each-state","chapter":"4 F2 recombination blocks (old)","heading":"4.5.2 Proportion of sites covered by each state","text":"","code":""},{"path":"f2-recombination-blocks-old.html","id":"genome-wide","chapter":"4 F2 recombination blocks (old)","heading":"4.5.2.1 Genome-wide","text":"\nFigure 4.1: Frequency based number sites\n","code":"\ndf %>% \n  # get counts of sites per LANE and state\n  dplyr::group_by(LANE, state) %>% \n  dplyr::count() %>% \n  # spread to one row per LANE\n  tidyr::pivot_wider(id_cols = LANE, names_from = state, values_from = n) %>% \n  # calculate frequencies of states per LANE\n  dplyr::mutate(TOTAL = sum(`0`, `1`, `2`),\n                FREQ_0 = `0` / TOTAL,\n                FREQ_1 = `1` / TOTAL,\n                FREQ_2 = `2` / TOTAL) %>% \n  # gather\n  tidyr::pivot_longer(cols = starts_with(\"FREQ_\"),\n                      names_to = \"STATE\",\n                      names_prefix = \"FREQ_\",\n                      values_to = \"FREQ\") %>% \n  # order STATE and recode with meaning\n  dplyr::mutate(STATE = factor(STATE, levels = c(0,1,2)),\n                STATE_RECODE = dplyr::recode(STATE,\n                                      `0` = \"Homozygous Cab\",\n                                      `1` = \"Heterozygous\",\n                                      `2` = \"Homozygous Kaga\")) %>% \n  # plot\n  ggplot(aes(STATE_RECODE, FREQ, colour = STATE, fill = STATE)) +\n    geom_violin() +\n    geom_boxplot(width = .5) +\n    ggbeeswarm::geom_quasirandom(color=\"#7D8491\", size=0.4, alpha=0.9) +\n    theme_bw() +\n    scale_colour_manual(values = pal_hom_het_2_lines) +\n    scale_fill_manual(values = pal_hom_het_2) +\n    guides(colour = \"none\", fill = \"none\") +\n    xlab(\"Genotype\") +\n    ylab(\"Frequency\")\nggsave(here::here(\"plots/20211027_gt_freqs_sites.png\"),\n       device = \"png\",\n       width = 10,\n       height = 5.8,\n       units = \"in\",\n       dpi = 400)"},{"path":"f2-recombination-blocks-old.html","id":"per-chromosome","chapter":"4 F2 recombination blocks (old)","heading":"4.5.2.2 Per chromosome","text":"\nFigure 4.2: Frequency per-chromosome based number sites\n","code":"\ndf %>% \n  dplyr::mutate(state = factor(state, levels = 0:2)) %>% \n  # get counts of sites per LANE and state\n  dplyr::group_by(LANE, chr, state) %>%\n  dplyr::count(.drop = F) %>% \n  # spread to one row per LANE\n  tidyr::pivot_wider(id_cols = c(LANE, chr), names_from = state, values_from = n) %>% \n  # replace NAs with 0 manually , because `.drop = F` in `count` above doesn't work \n  dplyr::mutate(dplyr::across(c(`0`, `1`, `2`),\n                            ~tidyr::replace_na(.x, 0))) %>% \n  # calculate frequencies of states per LANE\n  dplyr::mutate(TOTAL = sum(`0`, `1`, `2`, na.rm = T),\n                FREQ_0 = `0` / TOTAL,\n                FREQ_1 = `1` / TOTAL,\n                FREQ_2 = `2` / TOTAL) %>% \n  # gather\n  tidyr::pivot_longer(cols = starts_with(\"FREQ_\"),\n                      names_to = \"STATE\",\n                      names_prefix = \"FREQ_\",\n                      values_to = \"FREQ\") %>% \n  # order STATE and recode with meaning\n  dplyr::mutate(STATE = factor(STATE, levels = c(0,1,2)),\n                STATE_RECODE = dplyr::recode(STATE,\n                                      `0` = \"Homozygous Cab\",\n                                      `1` = \"Heterozygous\",\n                                      `2` = \"Homozygous Kaga\")) %>% \n  # plot\n  ggplot(aes(STATE_RECODE, FREQ, colour = STATE, fill = STATE)) +\n    geom_violin() +\n    geom_boxplot(width = .1) +\n    ggbeeswarm::geom_quasirandom(color=\"#7D8491\", size=0.1, alpha=0.7) +\n    theme_bw() +\n    scale_colour_manual(values = pal_hom_het_2_lines) +\n    scale_fill_manual(values = pal_hom_het_2) +\n    guides(colour = \"none\", fill = \"none\") +\n    xlab(\"Genotype\") +\n    ylab(\"Frequency\") +\n    facet_wrap(~chr, nrow = 4, ncol = 6) +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1))"},{"path":"f2-recombination-blocks-old.html","id":"karyoplot-2","chapter":"4 F2 recombination blocks (old)","heading":"4.6 Karyoplot","text":"Make custom chromosome scaffoldConvert data list block boundaries LANEExtract y cutoff points lanePlot karyoplots\nFigure 4.3: Bin length: 5 kb\nDon’t show bin lengths look .","code":"\n##Create custom genome \nmed_genome = regioneR::toGRanges(med_chr_lens)\nbb_list = purrr::map(df_list, function(df){\n  # loop over different bin lengths\n  block_bounds_list = df %>% \n    # loop over LANE\n    split(., f = .$LANE) %>% \n    purrr::map(., function(LANE){\n      # loop over CHR\n      LANE %>% \n        split(., f = .$chr) %>% \n        purrr::map(., function(CHR){\n          # Get lengths of each contiguous state\n          cont_len = rle(CHR$state)\n          \n          # Get cumulative sum of those lengths\n          cum_blocks = cumsum(cont_len$lengths)\n          \n          # Get rows that correspond to block changes\n          block_bounds = CHR[cum_blocks, ] %>% \n            # Add end of previous block\n            dplyr::mutate(END_PREV = dplyr::lag(BIN_END)) %>% \n            # Replace the NA in the first row with `1`\n            dplyr::mutate(END_PREV = tidyr::replace_na(END_PREV, 1)) %>% \n            # Add colour\n            dplyr::mutate(COLOUR = dplyr::recode(state,\n                                                 !!!pal_hom_het_2[-which(names(pal_hom_het_2) == \"UNCLASSIFIED\")])) \n          \n        }) %>% \n            dplyr::bind_rows()\n      \n  })\n})\nlc_list = purrr::map(bb_list, function(block_bounds_list){\n  lane_cutoffs = cut(0:1, breaks = length(block_bounds_list), dig.lab = 7) %>% \n    levels(.) %>% \n    data.frame(lower = as.numeric( sub(\"\\\\((.+),.*\", \"\\\\1\", .) ),\n               upper = as.numeric( sub(\"[^,]*,([^]]*)\\\\]\", \"\\\\1\", .) )) %>% \n    dplyr::arrange(dplyr::desc(lower))\n  return(lane_cutoffs)\n})\ncounter_A = 0\npurrr::map(bb_list, function(block_bounds_list){\n  counter_A <<- counter_A + 1\n  # set file name\n  file_name = paste(\"20211027_karyoplot_\", names(bb_list)[counter_A], \".png\", sep = \"\")\n  file_out = here::here(\"book/plots\", file_name)\n  \n  # Get lane cutoffs\n  lane_cutoffs = lc_list[[counter_A]]\n  \n  png(file=file_out,\n      width=13000,\n      height=26000,\n      units = \"px\",\n      res = 300)\n  \n  # Plot ideogram\n  kp = karyoploteR::plotKaryotype(med_genome, plot.type = 5)\n  # Add data background\n  #karyoploteR::kpDataBackground(kp, r0=0, r1 = 1, color = \"white\")\n  \n  # Add rectangles in loop\n  counter_B = 0\n  purrr::map(block_bounds_list, function(LANE){\n    # Add to counter_B\n    counter_B <<- counter_B + 1\n    # Add rectangles\n    karyoploteR::kpRect(kp,\n                        chr = LANE$chr,\n                        x0 = LANE$END_PREV,\n                        x1 = LANE$BIN_END,\n                        y0 = lane_cutoffs[counter_B, ] %>% \n                          dplyr::pull(lower),\n                        y1 = lane_cutoffs[counter_B, ] %>% \n                          dplyr::pull(upper),\n                        col = LANE$COLOUR,\n                        border = NA)\n    # Add axis label\n    karyoploteR::kpAddLabels(kp, labels = unique(LANE$LANE),\n                             r0 = lane_cutoffs[counter_B, ] %>% \n                               dplyr::pull(lower),\n                             r1 = lane_cutoffs[counter_B, ] %>% \n                               dplyr::pull(upper),\n                             cex = 0.5)\n  })\n  \n  \n  dev.off()  \n})\nknitr::include_graphics(here::here(\"book/plots/20211027_karyoplot_5000.png\"))\nknitr::include_graphics(here::here(\"book/plots/20211027_karyoplot_10000.png\"))\nknitr::include_graphics(here::here(\"book/plots/20211027_karyoplot_15000.png\"))\nknitr::include_graphics(here::here(\"book/plots/20211027_karyoplot_20000.png\"))"},{"path":"f2-recombination-blocks-old.html","id":"realised-relationship-matrix","chapter":"4 F2 recombination blocks (old)","heading":"4.7 Realised relationship matrix","text":"","code":""},{"path":"f2-recombination-blocks-old.html","id":"process-data","chapter":"4 F2 recombination blocks (old)","heading":"4.7.1 Process data","text":"","code":"\n# Process data\ngt_mat_rc = df_list$`5000` %>% \n  # extract LANE names from sample name, and create site name by binding `chr` and `block`\n  dplyr::mutate(LANE = basename(sample) %>% \n                  stringr::str_remove(\".txt\") %>% \n                  as.numeric(.),\n                SITE = paste(chr, bin, sep = \":\")) %>% \n## dplyr::filter(SITE %in% unique(SITE)[1:10]) %>% \n  dplyr::select(LANE, SITE, state) %>% \n  # recode 0,1,2 to -1,0,1\n  dplyr::mutate(state = dplyr::recode(state,\n                                      `0` = -1,\n                                      `1` = 0,\n                                      `2` = 1)) %>% \n  # pivot to put sites into columns\n  tidyr::pivot_wider(id_cols = c(LANE, SITE),\n                     names_from = SITE,\n                     values_from = state) %>% \n  # remove LANE column\n  dplyr::select(-LANE) %>% \n  # convert to matrix\n  as.matrix(.)\n\n#Compute realised relationship matrix\nrrmat = sommer::A.mat(gt_mat_rc)\n\n#Save object\nsaveRDS(rrmat, here::here(\"data/realised_relationship_matrix.rds\"))"},{"path":"f2-recombination-blocks-old.html","id":"plot","chapter":"4 F2 recombination blocks (old)","heading":"4.7.2 Plot","text":"","code":"\nrrmat = readRDS(here::here(\"data/realised_relationship_matrix.rds\"))\n\npng(here::here(\"book/plots/20211027_rrm_heatmap.png\"),\n    width = 20,\n    height = 20,\n    units = \"in\",\n    res = 400)\n\nheat_cols = colorRampPalette(c(\"#9EC5AB\", \"#0D4045\"))\nheatmap(rrmat, symm = T, col = heat_cols(100))\n\ndev.off()\nknitr::include_graphics(here::here(\"book/plots/20211027_rrm_heatmap.png\"))"},{"path":"f2-recombination-blocks-new.html","id":"f2-recombination-blocks-new","chapter":"5 F2 recombination blocks (new)","heading":"5 F2 recombination blocks (new)","text":"","code":"\nlibrary(here)\nsource(here::here(\"book/source/03-F2_recombination.R\"))"},{"path":"f2-recombination-blocks-new.html","id":"read-in-data-3","chapter":"5 F2 recombination blocks (new)","heading":"5.1 Read in data","text":"","code":"\nin_dir = \"/nfs/research/birney/users/ian/somites/recombination_blocks/F2/no_repeat_reads\"\n\nin_files = list.files(in_dir, full.names = T)\n\n##Read into list\ndata_list = purrr::map(in_files, function(FILE){\n  out = readr::read_tsv(FILE,\n                        col_types = \"ciiidii\")\n})\n##Set names as bin length\nnames(data_list) = basename(in_files) %>% \n  stringr::str_remove(\".txt\")\n##Reorder\ndata_list = data_list[order(as.numeric(names(data_list)))]\n\ncounter = 0\ndf_list = purrr::map(data_list, function(data){\n  counter <<- counter + 1\n  # set bin length\n  bin_length = as.numeric(names(data_list)[counter])\n  # add bin start and end coordinates\n  df = data %>% \n    dplyr::mutate(LANE = basename(sample) %>% \n                    stringr::str_remove(\".txt\") %>% \n                    as.numeric(.),\n                  BIN_LENGTH = bin_length,\n                  BIN_START = (bin - 1) * bin_length + 1,\n                  BIN_END = bin * bin_length,\n                  BIN_LENGTH_KB = BIN_LENGTH / 1e3,\n                  READS_PER_BIN = mat + pat)\n  return(df)\n})"},{"path":"f2-recombination-blocks-new.html","id":"examine-relationship-between-ratio-and-state-1","chapter":"5 F2 recombination blocks (new)","heading":"5.2 Examine relationship between ratio and state","text":"determine state associated parental strain.pipeline, set Cab F0_1 Kaga F0_2.ratio = mat / (mat + pat), mat = Cab pat = Kaga.Plot ratio stateThis shows state 0 associated low ratio Cab Kaga, therefore call Kaga.\nVice versa state 2 Cab.","code":"\nhead(df_list$`5000`) %>% \n  DT::datatable(.)\ndf_list$`5000` %>%\n  dplyr::mutate(state = factor(state, levels = 0:2)) %>% \n  dplyr::slice_sample(n = 1e6) %>% \n  ggplot() +\n    geom_boxplot(aes(state, ratio)) +\n    guides(colour = \"none\") +\n    theme_bw()\n##Save\nggsave(here::here(\"book/plots/20211110_ratio_v_state.png\"),\n       device = \"png\",\n       width = 8,\n       height = 5,\n       units = \"in\",\n       dpi = 400)\nknitr::include_graphics(here::here(\"book/plots/20211110_ratio_v_state.png\"))"},{"path":"f2-recombination-blocks-new.html","id":"recode-state-to-put-in-correct-order-1","chapter":"5 F2 recombination blocks (new)","heading":"5.2.1 Recode state to put in correct order","text":"","code":"\ndf_list = purrr::map(df_list, function(df){\n  df = df %>% \n    dplyr::mutate(state = dplyr::recode(state,\n                                        `0` = 2,\n                                        `1` = 1,\n                                        `2` = 0))\n})"},{"path":"f2-recombination-blocks-new.html","id":"read-counts-per-bin-1","chapter":"5 F2 recombination blocks (new)","heading":"5.3 Read counts per bin","text":"","code":"\n##How many bins in each data frame? \npurrr::map_int(df_list, nrow)\n#>     5000    10000    15000    20000 \n#> 31415601 19272763 14102988 11171064\n\n##Plot\ndf_list %>% \n  dplyr::bind_rows() %>% \n  dplyr::slice_sample(n = 1e5) %>% \n  dplyr::mutate(BIN_LENGTH_KB = factor(BIN_LENGTH_KB, levels = unique(BIN_LENGTH_KB)[order(unique(BIN_LENGTH_KB))])) %>% \n  # Plot\n  ggplot(aes(BIN_LENGTH_KB, log10(READS_PER_BIN), fill = BIN_LENGTH_KB)) +\n    geom_boxplot() +\n    theme_bw() +\n    scale_fill_manual(values = c(\"#778DA9\", \"#415A77\", \"#1B263B\", \"#0D1B2A\")) +\n    guides(fill = \"none\")\n#> Warning: Removed 78 rows containing non-finite values\n#> (stat_boxplot)."},{"path":"f2-recombination-blocks-new.html","id":"read-counts-by-proportion-of-kaga-1","chapter":"5 F2 recombination blocks (new)","heading":"5.4 Read counts by proportion of Kaga","text":"","code":"\ndf_list %>% \n  dplyr::bind_rows() %>% \n  dplyr::slice_sample(n = 1e5) %>% \n  dplyr::mutate(PROP_KAGA = pat / READS_PER_BIN ) %>% \n  # Plot\n  ggplot(aes(READS_PER_BIN, PROP_KAGA)) +\n    geom_point(alpha = 0.2) +\n    theme_bw() +\n    facet_grid(cols = vars(BIN_LENGTH)) +\n##   scale_colour_manual(values = c(\"#778DA9\", \"#415A77\", \"#1B263B\", \"#0D1B2A\")) +\n    guides(fill = \"none\")\n#> Warning: Removed 76 rows containing missing values\n#> (geom_point).\n\n##Limit to bins with 0-100 reads\ndf_list %>% \n  dplyr::bind_rows() %>% \n  dplyr::slice_sample(n = 1e5) %>% \n  dplyr::mutate(PROP_KAGA = pat / READS_PER_BIN ) %>% \n  # Plot\n  ggplot(aes(READS_PER_BIN, PROP_KAGA)) +\n    geom_point(alpha = 0.2) +\n    theme_bw() +\n    facet_grid(cols = vars(BIN_LENGTH)) +\n##   scale_colour_manual(values = c(\"#778DA9\", \"#415A77\", \"#1B263B\", \"#0D1B2A\")) +\n    guides(fill = \"none\") +\n    xlim(0,100)\n#> Warning: Removed 20030 rows containing missing values\n#> (geom_point)."},{"path":"f2-recombination-blocks-new.html","id":"proportion-of-genome-and-sites-called-as-a-given-state-1","chapter":"5 F2 recombination blocks (new)","heading":"5.5 Proportion of genome and sites called as a given state","text":"","code":""},{"path":"f2-recombination-blocks-new.html","id":"proportion-of-genome-covered-by-each-state-1","chapter":"5 F2 recombination blocks (new)","heading":"5.5.1 Proportion of genome covered by each state","text":"","code":""},{"path":"f2-recombination-blocks-new.html","id":"read-in-total-medaka-genome-count-2","chapter":"5 F2 recombination blocks (new)","heading":"5.5.1.1 Read in total medaka genome count","text":"","code":"\n##Get chromosome lengths\nmed_chr_lens = read.table(here::here(\"data\",\n                                     \"Oryzias_latipes.ASM223467v1.dna.toplevel.fa_chr_counts.txt\"),\n                          col.names = c(\"chr\", \"end\"))\n##Add start\nmed_chr_lens$start = 1\n##Reorder\nmed_chr_lens = med_chr_lens %>% \n  dplyr::select(chr, start, end) %>% \n  # remove MT\n  dplyr::filter(chr != \"MT\")\n\n##Total HdrR sequence length\ntotal_hdrr_bases = sum(med_chr_lens$end)"},{"path":"f2-recombination-blocks-new.html","id":"get-total-number-of-bases-covered-by-each-state-3","chapter":"5 F2 recombination blocks (new)","heading":"5.5.1.2 Get total number of bases covered by each state","text":"Plot","code":"\n##Take 5kb DF\ndf = df_list$`5000`\n\n##Set states to loop over\nstates = 0:2\nnames(states) = states\n\n##Run loop over each LANE\n\nbase_cov_df = df %>% \n  split(., f = .$LANE) %>% \n  purrr::map(., function(LANE){\n    # convert to ranges object\n    lane_ranges = GenomicRanges::makeGRangesFromDataFrame(LANE,\n                                                          keep.extra.columns = T,\n                                                          ignore.strand = T,\n                                                          seqnames.field = \"chr\", \n                                                          start.field = \"BIN_START\",\n                                                          end.field = \"BIN_END\")\n    # get total bases covered by each state\n    purrr::map_dfr(states, function(STATE){\n      lane_ranges[lane_ranges$state == STATE] %>% \n        # merge contiguous ranges\n        GenomicRanges::reduce(.) %>% \n        # get width of ranges\n        width(.) %>% \n        # get total bases covered\n        sum(.) %>% \n        # coerce into data frame\n        data.frame(\"BASES_COVERED\" = .)\n      }, .id = \"STATE\") %>% \n        # add FREQ column\n        dplyr::mutate(FREQ = BASES_COVERED / total_hdrr_bases) %>% \n        # add UNCLASSIFIED row\n        tibble::add_row(STATE = \"UNCLASSIFIED\", \n                        BASES_COVERED = total_hdrr_bases - sum(.$BASES_COVERED),\n                        FREQ = (total_hdrr_bases - sum(.$BASES_COVERED)) / total_hdrr_bases)\n    }\n  ) %>% \n  dplyr::bind_rows(.id = \"LANE\")\n##Plot\nbase_cov_df %>% \n  dplyr::mutate(STATE = factor(STATE, levels = c(0,1,2, \"UNCLASSIFIED\")),\n                STATE_RECODE = dplyr::recode(STATE,\n                                             `0` = \"Homozygous Cab\",\n                                             `1` = \"Heterozygous\",\n                                             `2` = \"Homozygous Kaga\",\n                                             \"UNCLASSIFIED\" = \"Unclassified\")) %>% \n  # plot\n  ggplot(aes(STATE_RECODE, FREQ, colour = STATE, fill = STATE)) +\n    geom_violin() +\n    geom_boxplot(width = .3) +\n    ggbeeswarm::geom_quasirandom(color=\"#7D8491\", size=0.4, alpha=0.9) +\n    theme_bw() +\n    scale_colour_manual(values = pal_hom_het_2_lines) +\n    scale_fill_manual(values = pal_hom_het_2) +\n    guides(colour = \"none\", fill = \"none\") +\n    xlab(\"Genotype\") +\n    ylab(\"Proportion of reference bases covered\")"},{"path":"f2-recombination-blocks-new.html","id":"by-chromosome-1","chapter":"5 F2 recombination blocks (new)","heading":"5.5.1.3 By chromosome","text":"Process.Plot","code":"\n##Set states to loop over\nstates = 0:2\nnames(states) = states\n\n##Run loop over each LANE\n\nbase_cov_df_chr = df %>% \n  split(., f = .$LANE) %>% \n    purrr::map(., function(LANE){\n      # convert to ranges object\n      lane_ranges = GenomicRanges::makeGRangesFromDataFrame(LANE,\n                                                            keep.extra.columns = T,\n                                                            ignore.strand = T,\n                                                            seqnames.field = \"chr\", \n                                                            start.field = \"BIN_START\",\n                                                            end.field = \"BIN_END\")\n      # loop over each chromosome\n      purrr::map(med_chr_lens$chr, function(CHR){\n        # get total length of target chromosome\n        target_chr_len = med_chr_lens$end[med_chr_lens$chr == CHR]\n        # get total bases covered by each state per chromosome\n        purrr::map_dfr(states, function(STATE){\n          lane_ranges[lane_ranges$state == STATE & lane_ranges@seqnames == CHR] %>% \n            # merge contiguous ranges\n            GenomicRanges::reduce(.) %>% \n            # get width of ranges\n            width(.) %>% \n            # get total bases covered\n            sum(.) %>% \n            # coerce into data frame\n            data.frame(\"BASES_COVERED\" = .)\n          }, .id = \"STATE\") %>% \n            # add FREQ column\n            dplyr::mutate(FREQ = BASES_COVERED / target_chr_len ) %>% \n            # add UNCLASSIFIED row\n            tibble::add_row(STATE = \"UNCLASSIFIED\", \n                            BASES_COVERED = target_chr_len - sum(.$BASES_COVERED),\n                            FREQ = (target_chr_len - sum(.$BASES_COVERED)) / target_chr_len)\n      }) %>% \n        dplyr::bind_rows(.id = \"CHR\")\n    }\n  ) %>% \n  dplyr::bind_rows(.id = \"LANE\")\nsaveRDS(base_cov_df_chr, here::here(\"data/20211110_base_cov_per_chr.rds\"))\n##Plot\nbase_cov_df_chr %>% \n  dplyr::mutate(STATE = factor(STATE, levels = c(0,1,2, \"UNCLASSIFIED\")),\n                STATE_RECODE = dplyr::recode(STATE,\n                                             `0` = \"Homozygous Cab\",\n                                             `1` = \"Heterozygous\",\n                                             `2` = \"Homozygous Kaga\",\n                                             \"UNCLASSIFIED\" = \"Unclassified\"),\n                CHR = factor(CHR, levels = med_chr_lens$chr)) %>% \n  # plot\n  ggplot(aes(STATE_RECODE, FREQ, colour = STATE, fill = STATE)) +\n    geom_violin() +\n    geom_boxplot(width = .1) +\n    ggbeeswarm::geom_quasirandom(color=\"#7D8491\", size=0.1, alpha=0.7) +\n    theme_bw() +\n    scale_colour_manual(values = pal_hom_het_2_lines) +\n    scale_fill_manual(values = pal_hom_het_2) +\n    guides(colour = \"none\", fill = \"none\") +\n    xlab(\"Genotype\") +\n    ylab(\"Proportion of reference bases covered\") +\n    facet_wrap(~CHR, nrow = 4, ncol = 6) +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1))"},{"path":"f2-recombination-blocks-new.html","id":"proportion-of-sites-covered-by-each-state-1","chapter":"5 F2 recombination blocks (new)","heading":"5.5.2 Proportion of sites covered by each state","text":"","code":""},{"path":"f2-recombination-blocks-new.html","id":"genome-wide-1","chapter":"5 F2 recombination blocks (new)","heading":"5.5.2.1 Genome-wide","text":"\nFigure 4.1: Frequency based number sites\n","code":"\ndf %>% \n  # get counts of sites per LANE and state\n  dplyr::group_by(LANE, state) %>% \n  dplyr::count() %>% \n  # spread to one row per LANE\n  tidyr::pivot_wider(id_cols = LANE, names_from = state, values_from = n) %>% \n  # calculate frequencies of states per LANE\n  dplyr::mutate(TOTAL = sum(`0`, `1`, `2`),\n                FREQ_0 = `0` / TOTAL,\n                FREQ_1 = `1` / TOTAL,\n                FREQ_2 = `2` / TOTAL) %>% \n  # gather\n  tidyr::pivot_longer(cols = starts_with(\"FREQ_\"),\n                      names_to = \"STATE\",\n                      names_prefix = \"FREQ_\",\n                      values_to = \"FREQ\") %>% \n  # order STATE and recode with meaning\n  dplyr::mutate(STATE = factor(STATE, levels = c(0,1,2)),\n                STATE_RECODE = dplyr::recode(STATE,\n                                      `0` = \"Homozygous Cab\",\n                                      `1` = \"Heterozygous\",\n                                      `2` = \"Homozygous Kaga\")) %>% \n  # plot\n  ggplot(aes(STATE_RECODE, FREQ, colour = STATE, fill = STATE)) +\n    geom_violin() +\n    geom_boxplot(width = .5) +\n    ggbeeswarm::geom_quasirandom(color=\"#7D8491\", size=0.4, alpha=0.9) +\n    theme_bw() +\n    scale_colour_manual(values = pal_hom_het_2_lines) +\n    scale_fill_manual(values = pal_hom_het_2) +\n    guides(colour = \"none\", fill = \"none\") +\n    xlab(\"Genotype\") +\n    ylab(\"Frequency\")\nggsave(here::here(\"plots/20211110_gt_freqs_sites.png\"),\n       device = \"png\",\n       width = 10,\n       height = 5.8,\n       units = \"in\",\n       dpi = 400)"},{"path":"f2-recombination-blocks-new.html","id":"per-chromosome-1","chapter":"5 F2 recombination blocks (new)","heading":"5.5.2.2 Per chromosome","text":"\nFigure 4.2: Frequency per-chromosome based number sites\n","code":"\ndf %>% \n  dplyr::mutate(state = factor(state, levels = 0:2)) %>% \n  # get counts of sites per LANE and state\n  dplyr::group_by(LANE, chr, state) %>%\n  dplyr::count(.drop = F) %>% \n  # spread to one row per LANE\n  tidyr::pivot_wider(id_cols = c(LANE, chr), names_from = state, values_from = n) %>% \n  # replace NAs with 0 manually , because `.drop = F` in `count` above doesn't work \n  dplyr::mutate(dplyr::across(c(`0`, `1`, `2`),\n                            ~tidyr::replace_na(.x, 0))) %>% \n  # calculate frequencies of states per LANE\n  dplyr::mutate(TOTAL = sum(`0`, `1`, `2`, na.rm = T),\n                FREQ_0 = `0` / TOTAL,\n                FREQ_1 = `1` / TOTAL,\n                FREQ_2 = `2` / TOTAL) %>% \n  # gather\n  tidyr::pivot_longer(cols = starts_with(\"FREQ_\"),\n                      names_to = \"STATE\",\n                      names_prefix = \"FREQ_\",\n                      values_to = \"FREQ\") %>% \n  # order STATE and recode with meaning\n  dplyr::mutate(STATE = factor(STATE, levels = c(0,1,2)),\n                STATE_RECODE = dplyr::recode(STATE,\n                                      `0` = \"Homozygous Cab\",\n                                      `1` = \"Heterozygous\",\n                                      `2` = \"Homozygous Kaga\")) %>% \n  # plot\n  ggplot(aes(STATE_RECODE, FREQ, colour = STATE, fill = STATE)) +\n    geom_violin() +\n    geom_boxplot(width = .1) +\n    ggbeeswarm::geom_quasirandom(color=\"#7D8491\", size=0.1, alpha=0.7) +\n    theme_bw() +\n    scale_colour_manual(values = pal_hom_het_2_lines) +\n    scale_fill_manual(values = pal_hom_het_2) +\n    guides(colour = \"none\", fill = \"none\") +\n    xlab(\"Genotype\") +\n    ylab(\"Frequency\") +\n    facet_wrap(~chr, nrow = 4, ncol = 6) +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1))"},{"path":"f2-recombination-blocks-new.html","id":"karyoplot-3","chapter":"5 F2 recombination blocks (new)","heading":"5.6 Karyoplot","text":"Make custom chromosome scaffoldConvert data list block boundaries LANEExtract y cutoff points lanePlot karyoplots\nFigure 4.3: Bin length: 5 kb\nDon’t show bin lengths look .","code":"\n##Create custom genome \nmed_genome = regioneR::toGRanges(med_chr_lens)\nbb_list = purrr::map(df_list, function(df){\n  # loop over different bin lengths\n  block_bounds_list = df %>% \n    # loop over LANE\n    split(., f = .$LANE) %>% \n    purrr::map(., function(LANE){\n      # loop over CHR\n      LANE %>% \n        split(., f = .$chr) %>% \n        purrr::map(., function(CHR){\n          # Get lengths of each contiguous state\n          cont_len = rle(CHR$state)\n          \n          # Get cumulative sum of those lengths\n          cum_blocks = cumsum(cont_len$lengths)\n          \n          # Get rows that correspond to block changes\n          block_bounds = CHR[cum_blocks, ] %>% \n            # Add end of previous block\n            dplyr::mutate(END_PREV = dplyr::lag(BIN_END)) %>% \n            # Replace the NA in the first row with `1`\n            dplyr::mutate(END_PREV = tidyr::replace_na(END_PREV, 1)) %>% \n            # Add colour\n            dplyr::mutate(COLOUR = dplyr::recode(state,\n                                                 !!!pal_hom_het_2[-which(names(pal_hom_het_2) == \"UNCLASSIFIED\")])) \n          \n        }) %>% \n            dplyr::bind_rows()\n      \n  })\n})\nlc_list = purrr::map(bb_list, function(block_bounds_list){\n  lane_cutoffs = cut(0:1, breaks = length(block_bounds_list), dig.lab = 7) %>% \n    levels(.) %>% \n    data.frame(lower = as.numeric( sub(\"\\\\((.+),.*\", \"\\\\1\", .) ),\n               upper = as.numeric( sub(\"[^,]*,([^]]*)\\\\]\", \"\\\\1\", .) )) %>% \n    dplyr::arrange(dplyr::desc(lower))\n  return(lane_cutoffs)\n})\ncounter_A = 0\npurrr::map(bb_list, function(block_bounds_list){\n  counter_A <<- counter_A + 1\n  # set file name\n  file_name = paste(\"20211110_karyoplot_\", names(bb_list)[counter_A], \".png\", sep = \"\")\n  file_out = here::here(\"book/plots\", file_name)\n  \n  # Get lane cutoffs\n  lane_cutoffs = lc_list[[counter_A]]\n  \n  png(file=file_out,\n      width=13000,\n      height=26000,\n      units = \"px\",\n      res = 300)\n  \n  # Plot ideogram\n  kp = karyoploteR::plotKaryotype(med_genome, plot.type = 5)\n  # Add data background\n  #karyoploteR::kpDataBackground(kp, r0=0, r1 = 1, color = \"white\")\n  \n  # Add rectangles in loop\n  counter_B = 0\n  purrr::map(block_bounds_list, function(LANE){\n    # Add to counter_B\n    counter_B <<- counter_B + 1\n    # Add rectangles\n    karyoploteR::kpRect(kp,\n                        chr = LANE$chr,\n                        x0 = LANE$END_PREV,\n                        x1 = LANE$BIN_END,\n                        y0 = lane_cutoffs[counter_B, ] %>% \n                          dplyr::pull(lower),\n                        y1 = lane_cutoffs[counter_B, ] %>% \n                          dplyr::pull(upper),\n                        col = LANE$COLOUR,\n                        border = NA)\n    # Add axis label\n    karyoploteR::kpAddLabels(kp, labels = unique(LANE$LANE),\n                             r0 = lane_cutoffs[counter_B, ] %>% \n                               dplyr::pull(lower),\n                             r1 = lane_cutoffs[counter_B, ] %>% \n                               dplyr::pull(upper),\n                             cex = 0.5)\n  })\n  \n  \n  dev.off()  \n})\nknitr::include_graphics(here::here(\"book/plots/20211110_karyoplot_5000.png\"))\nknitr::include_graphics(here::here(\"book/plots/20211110_karyoplot_10000.png\"))\nknitr::include_graphics(here::here(\"book/plots/20211110_karyoplot_15000.png\"))\nknitr::include_graphics(here::here(\"book/plots/20211110_karyoplot_20000.png\"))"},{"path":"association-testing-with-simulated-phenotypes.html","id":"association-testing-with-simulated-phenotypes","chapter":"6 Association testing with simulated phenotypes","heading":"6 Association testing with simulated phenotypes","text":"","code":"\nlibrary(here)\nsource(here::here(\"book/source/04-Association_testing.R\"))"},{"path":"association-testing-with-simulated-phenotypes.html","id":"read-in-f2-recombination-blocks","chapter":"6 Association testing with simulated phenotypes","heading":"6.1 Read in F2 recombination blocks","text":"","code":""},{"path":"association-testing-with-simulated-phenotypes.html","id":"read-data","chapter":"6 Association testing with simulated phenotypes","heading":"6.1.1 Read data","text":"","code":"\nin_dir = \"/nfs/research/birney/users/ian/somites/recombination_blocks/20211027\"\n\nin_files = list.files(in_dir, pattern = \"F2_\", full.names = T)\n\n# Read into list\ndata_list = purrr::map(in_files, function(FILE){\n  out = readr::read_tsv(FILE,\n                        col_types = \"ciiidii\")\n})\n# Set names as bin length\nnames(data_list) = basename(in_files) %>% \n  stringr::str_split(\"_\", simplify = T) %>% \n  subset(select = 2) %>% \n  stringr::str_remove(\".txt\")\n# Reorder\ndata_list = data_list[order(as.numeric(names(data_list)))]\n\ncounter = 0\ndf_list = purrr::map(data_list, function(data){\n  counter <<- counter + 1\n  # set bin length\n  bin_length = as.numeric(names(data_list)[counter])\n  # add bin start and end coordinates\n  df = data %>% \n    dplyr::mutate(SAMPLE = basename(sample) %>% \n                    stringr::str_remove(\".txt\") %>% \n                    as.numeric(.),\n                  BIN_START = (bin - 1) * bin_length + 1,\n                  BIN_END = bin * bin_length) %>% \n    # recode state to make 0 == \"Cab\"\n    dplyr::mutate(STATE = dplyr::recode(state,\n                                        `0` = 2,\n                                        `1` = 1,\n                                        `2` = 0)) %>% \n    dplyr::select(SAMPLE, CHROM = chr, BIN = bin, BIN_START, BIN_END, STATE)\n  \n  return(df)\n})"},{"path":"association-testing-with-simulated-phenotypes.html","id":"how-many-possible-blocks-have-at-least-one-call","chapter":"6 Association testing with simulated phenotypes","heading":"6.1.2 How many possible blocks have at least one call?","text":"","code":""},{"path":"association-testing-with-simulated-phenotypes.html","id":"count-total-existing-bins","chapter":"6 Association testing with simulated phenotypes","heading":"6.1.2.1 Count total existing bins","text":"","code":"\nbin_lengths = as.integer(names(df_list))\nnames(bin_lengths) = bin_lengths\n\nn_bins = purrr::map(bin_lengths, function(BIN_LENGTH){\n  purrr::map_int(med_chr_lens$end, function(CHR_END){\n    out = seq(from = 1, to = CHR_END, by = BIN_LENGTH)\n    \n    return(length(out))\n  })\n})\n\nn_bins_total = purrr::map_int(n_bins, sum)"},{"path":"association-testing-with-simulated-phenotypes.html","id":"proportion-of-total-bins-with-calls","chapter":"6 Association testing with simulated phenotypes","heading":"6.1.2.2 Proportion of total bins with calls","text":"","code":"\n# Get total number of samples\nn_samples = df_list$`5000`$SAMPLE %>%\n  unique(.) %>% \n  length(.)\n\n# Build DF of bins\nn_bins_df = purrr::map_dfr(1:length(df_list), function(COUNTER){\n  # Bin length\n  bin_length = as.numeric(names(df_list)[COUNTER])\n  # Number of total bins\n  n_bins = n_bins_total[COUNTER]\n  # Number of bins with calls\n  n_bins_with_calls = df_list[[COUNTER]] %>% \n    dplyr::distinct(CHROM, BIN_START) %>% \n    nrow(.)\n  # Number of bins with calls for each \n  n_bins_no_missing = df_list[[COUNTER]] %>% \n    dplyr::count(CHROM, BIN_START) %>%\n    dplyr::filter(n == n_samples) %>%\n    nrow(.)\n  \n  # Build final data frame\n  out = tibble::tibble(BIN_LENGTH = bin_length,\n                       N_BINS = n_bins,\n                       N_BINS_WITH_CALLS = n_bins_with_calls,\n                       N_BINS_NO_MISSING = n_bins_no_missing) %>% \n    dplyr::mutate(PROP_BINS_WITH_CALLS = N_BINS_WITH_CALLS / N_BINS,\n                  PROP_BINS_NO_MISSING = N_BINS_NO_MISSING / N_BINS )\n  \n  return(out)\n})\n\nDT::datatable(n_bins_df)"},{"path":"association-testing-with-simulated-phenotypes.html","id":"merge-recombination-blocks","chapter":"6 Association testing with simulated phenotypes","heading":"6.1.3 Merge recombination blocks","text":"","code":""},{"path":"association-testing-with-simulated-phenotypes.html","id":"list-with-final-recoded-genotypes-including-nas","chapter":"6 Association testing with simulated phenotypes","heading":"6.1.3.1 List with final recoded genotypes (including NAs)","text":"","code":"\ngt_list = purrr::map(df_list, function(BIN_LENGTH_DF){\n  \n  # Widen data frame\n  gt_final = BIN_LENGTH_DF %>% \n    tidyr::pivot_wider(names_from = SAMPLE, values_from = STATE)\n  \n  # Pull out matrix of genotypes\n  gt_mat = as.matrix(gt_final[, 5:ncol(gt_final)])\n  \n  # Get indexes of loci with > 1 genotype\n  bins_to_keep = logical()\n  \n  for (ROW in 1:nrow(gt_mat)){\n    # get unique values in each row\n    out = unique(gt_mat[ROW, ])\n    # remove NAs\n    out = out[!is.na(out)]\n    # if more than one value, return TRUE\n    if (length(out) > 1) {\n      bins_to_keep[ROW] = TRUE\n    }\n    # if just one value (i.e. if all samples are the same genotype at that locus), return false \n    else {\n      bins_to_keep[ROW] = FALSE\n    }\n  }\n  \n  # filter gt_final\n  gt_filt = gt_final %>% \n    dplyr::filter(bins_to_keep) %>% \n    # recode genotypes to -1, 0, 1\n    dplyr::mutate(dplyr::across(-c(\"CHROM\", \"BIN\", \"BIN_START\", \"BIN_END\"),\n                                ~dplyr::recode(.x,\n                                               `0` = -1,\n                                               `1` = 0,\n                                               `2` = 1))) %>% \n    # order\n    dplyr::arrange(CHROM, BIN_START)  \n  \n  return(gt_filt)\n}) \n\n# Show first 10 columns\ngt_list$`20000`[, 1:10] %>% \n  head(.) %>% \n  DT::datatable(.) "},{"path":"association-testing-with-simulated-phenotypes.html","id":"list-with-final-recoded-genotypes-complete-cases-only","chapter":"6 Association testing with simulated phenotypes","heading":"6.1.3.2 List with final recoded genotypes (complete cases only)","text":"","code":"\ngt_nomiss_list = purrr::map(gt_list, function(BIN_LENGTH_DF){\n  BIN_LENGTH_DF %>%\n    dplyr::filter(complete.cases(.))\n})"},{"path":"association-testing-with-simulated-phenotypes.html","id":"simulate-phenotype","chapter":"6 Association testing with simulated phenotypes","heading":"6.2 Simulate phenotype","text":"","code":""},{"path":"association-testing-with-simulated-phenotypes.html","id":"extract-samples-of-genotypes","chapter":"6 Association testing with simulated phenotypes","heading":"6.2.1 Extract samples of genotypes","text":"must written file PhenotypeSimulator reads delimited genotypes files.","code":"\n# Set directory\nout_dir_test = file.path(lts_dir, \"association_testing/20211027_test\")\n# Get random 10 loci\nset.seed(10)\nn_loci = 10\n# NOTE: PhenotypeSimulator::readStandardGenotypes states that the genotype file must\n# delim: a [delimter]-delimited file of [(NrSNPs+1) x (NrSamples+1)] genotypes with the snpIDs in the first column and the sampleIDs in the first row and genotypes encoded as numbers between 0 and 2 representing the (posterior) mean genotype, or dosage of the minor allele.\n\nsample_gts = purrr::map(seq_along(gt_nomiss_list), function(COUNTER){\n  \n  # Pull out random SNPs\n  snp_sample = gt_nomiss_list[[COUNTER]] %>% \n    dplyr::slice_sample(n = n_loci) %>% \n    dplyr::arrange(CHROM, BIN_START) %>% \n    # create locus column\n    dplyr::mutate(LOCUS = paste(CHROM, BIN_START, sep = \":\")) %>% \n    # remove superfluous columns\n    dplyr::select(-c(CHROM, BIN, BIN_START, BIN_END)) %>% \n    # recode back to 0,1,2\n    dplyr::mutate(dplyr::across(-LOCUS,\n                                ~dplyr::recode(.x,\n                                               `-1` = 0,\n                                               `0` = 1,\n                                               `1` = 2))) %>% \n    # reorder columns\n    dplyr::select(LOCUS, everything())\n  \n})\nnames(sample_gts) = names(gt_nomiss_list)\n\npurrr::map(seq_along(sample_gts), function(COUNTER){\n  # save to file\n  bin_length = names(sample_gts)[COUNTER]\n  out_file = file.path(out_dir_test, \"target_loci\", paste(bin_length, \".csv\", sep = \"\"))\n  readr::write_csv(sample_gts[[COUNTER]], out_file)\n})\n\nsaveRDS(sample_gts, file.path(out_dir_test, \"target_loci/sample_gts.rds\"))"},{"path":"association-testing-with-simulated-phenotypes.html","id":"simulate-phenotype-1","chapter":"6 Association testing with simulated phenotypes","heading":"6.2.2 Simulate phenotype","text":"","code":"\nsim_path = file.path(out_dir_test, \"simulated_phenotypes/20211103_sim_phenos.rds\")\nset.seed(5671)\n# N samples\nN = n_samples\n# N phenotypes\nP = 1\n# Proportion of total genetic variance\ngenVar = 0.5\n# Proportion of genetic variance of genetic variant effects\nh2s = 1\n# Proportion of total noise variance\nnoiseVar = 0.5\n# Proportion of noise variance of observational noise effects\nphi = 1\n\nsim_phenos = purrr::map(seq_along(sample_gts), function(COUNTER){\n  # get sample file path\n  bin_length = names(sample_gts)[COUNTER]\n  gt_sample_file = file.path(out_dir_test, \"target_loci\", paste(bin_length, \".csv\", sep = \"\"))\n    \n  sim_pheno = PhenotypeSimulator::runSimulation(N = N, P = P, \n                                                genVar = genVar, h2s = h2s, \n                                                noiseVar = noiseVar, phi = phi,\n                                                cNrSNP = n_loci,\n                                                genotypefile = gt_sample_file,\n                                                format = \"delim\",\n                                                genoDelimiter = \",\")\n  \n  return(sim_pheno)\n})\nnames(sim_phenos) = names(sample_gts)\n\nsaveRDS(sim_phenos, sim_path)\n\n# Write as .xlsx to use in same Snakemake code as true GWLS\nlapply(seq_along(sim_phenos), function(COUNTER){\n  out = tibble::tibble(fish = colnames(sample_gts[[COUNTER]])[-1],\n                       Y = sim_phenos[[COUNTER]]$phenoComponentsFinal$Y)\n  # set path for output\n  out_file = file.path(lts_dir, \n                       \"association_testing/20211027_test/simulated_phenotypes\",\n                       paste(names(sim_phenos)[COUNTER], \".xlsx\", sep = \"\"))\n  # write to file\n  openxlsx::write.xlsx(out, out_file, overwrite = T)\n})"},{"path":"association-testing-with-simulated-phenotypes.html","id":"reformat-genotypes-for-gridlmm","chapter":"6 Association testing with simulated phenotypes","heading":"6.3 Reformat genotypes for GridLMM","text":"","code":""},{"path":"association-testing-with-simulated-phenotypes.html","id":"complete-cases","chapter":"6 Association testing with simulated phenotypes","heading":"6.3.1 Complete cases","text":"","code":"\nfinal_nomiss = purrr::map(seq_along(gt_nomiss_list), function(COUNTER){\n  out = list()\n  \n  # Genotypes\n  out[[\"genotypes\"]] = gt_nomiss_list[[COUNTER]] %>% \n    dplyr::select(-c(CHROM, BIN, BIN_START, BIN_END)) %>% \n    # convert to matrix\n    as.matrix(.) %>% \n    # transpose to put samples as rows\n    t(.) %>% \n    # convert to data frame\n    as.data.frame(.)\n  \n  # Positions\n  out[[\"positions\"]] = gt_nomiss_list[[COUNTER]] %>% \n    dplyr::select(CHROM, BIN_START, BIN_END)\n  \n  # Phenotypes\n  out[[\"phenotypes\"]] = data.frame(fish = rownames(sim_phenos[[COUNTER]]$phenoComponentsFinal$Y),\n                                   Y = sim_phenos[[COUNTER]]$phenoComponentsFinal$Y %>%\n                                     as.numeric()\n                                   )\n    \n  return(out)\n})\nnames(final_nomiss) = names(gt_nomiss_list)"},{"path":"association-testing-with-simulated-phenotypes.html","id":"with-nas","chapter":"6 Association testing with simulated phenotypes","heading":"6.3.2 With NAs","text":"","code":"\nfinal_wimiss = purrr::map(seq_along(gt_list), function(COUNTER){\n  out = list()\n  \n  # Genotypes\n  out[[\"genotypes\"]] = gt_list[[COUNTER]] %>% \n    dplyr::select(-c(CHROM, BIN, BIN_START, BIN_END)) %>% \n    # convert to matrix\n    as.matrix(.) %>% \n    # transpose to put samples as rows\n    t(.) %>% \n    # convert to data frame\n    as.data.frame(.)\n  \n  # Positions\n  out[[\"positions\"]] = gt_list[[COUNTER]] %>% \n    dplyr::select(CHROM, BIN_START, BIN_END)\n  \n  # Phenotypes\n  out[[\"phenotypes\"]] = data.frame(SAMPLE = rownames(sim_phenos[[COUNTER]]$phenoComponentsFinal$Y),\n                                   Y = sim_phenos[[COUNTER]]$phenoComponentsFinal$Y %>%\n                                     as.numeric()\n                                   )\n    \n  return(out)\n})\nnames(final_wimiss) = names(gt_list)"},{"path":"association-testing-with-simulated-phenotypes.html","id":"test-gridlmm","chapter":"6 Association testing with simulated phenotypes","heading":"6.4 Test GridLMM","text":"","code":""},{"path":"association-testing-with-simulated-phenotypes.html","id":"no-missing","chapter":"6 Association testing with simulated phenotypes","heading":"6.4.1 No missing","text":"","code":""},{"path":"association-testing-with-simulated-phenotypes.html","id":"run-gwas","chapter":"6 Association testing with simulated phenotypes","heading":"6.4.1.1 Run GWAS","text":"","code":"\ntest_out_nomiss = file.path(out_dir_test, \"gwls_results\", \"gwas_results_nomiss.rds\")\ngwas_tests_nomiss = purrr::map(final_nomiss, function(BIN_LENGTH){\n  run_gwas(d = BIN_LENGTH$genotypes,\n           m = BIN_LENGTH$positions,\n           p = BIN_LENGTH$phenotypes)\n})\n\nsaveRDS(gwas_tests_nomiss, test_out_nomiss)"},{"path":"association-testing-with-simulated-phenotypes.html","id":"plot-1","chapter":"6 Association testing with simulated phenotypes","heading":"6.4.1.2 Plot","text":"","code":"\n# Create custom Manhattan plot\n\ntest_man_nomiss = lapply(seq_along(gwas_tests_nomiss), function(COUNTER){\n  # Get bin length\n  BIN_LENGTH = names(gwas_tests_nomiss)[COUNTER] %>% \n    as.numeric(.)\n  \n  # Clean data frame\n  test_results = gwas_tests_nomiss[[COUNTER]]$results %>% \n    dplyr::left_join(med_chr_lens, by = c(\"Chr\" = \"chr\")) %>% \n    # add x-coord\n    dplyr::mutate(X_COORD = pos + TOT) %>% \n    # change column names\n    dplyr::rename(CHROM = Chr, BIN_START = pos) %>% \n    # add BIN_END\n    dplyr::mutate(BIN_END = BIN_START + BIN_LENGTH - 1) %>% \n    # add locus\n    dplyr::mutate(LOCUS = paste(CHROM, BIN_START, sep = \":\")) %>%\n    # target or not\n    dplyr::mutate(TARGET = dplyr::if_else(LOCUS %in% sample_gts[[COUNTER]]$LOCUS,\n                                          \"yes\",\n                                          \"no\"),\n                  TARGET = factor(TARGET, levels = c(\"yes\", \"no\"))) %>% \n    # create vector of colours\n    dplyr::mutate(COLOUR = dplyr::case_when(TARGET == \"yes\" ~ names(gwas_pal)[1],\n                                            gtools::even(CHROM) ~ names(gwas_pal)[2],\n                                            gtools::odd(CHROM) ~ names(gwas_pal)[3]),\n                  # order so that `target` is plotted last, at the front\n                  COLOUR = factor(COLOUR, levels = rev(names(gwas_pal))),\n                  SHAPE = dplyr::if_else(TARGET == \"yes\",\n                                         18,\n                                         20),\n                  SIZE = dplyr::if_else(TARGET == \"yes\",\n                                         1,\n                                         0.5),\n                  ALPHA = dplyr::if_else(TARGET == \"yes\",\n                                         1,\n                                         0.5)\n                  )\n  \n  # Plot\n  p1 = test_results %>% \n    ggplot(aes(x = X_COORD,\n               y = -log10(p_value_REML),\n               colour = COLOUR,\n               shape = SHAPE,\n               size = SIZE,\n               alpha = ALPHA,\n               label = CHROM,\n               label2 = BIN_START,\n               label3 = BIN_END)) + \n    geom_point() +\n    aes(group = rev(TARGET)) +\n    scale_color_manual(values = gwas_pal) +\n    scale_shape_identity() +\n    scale_size_identity() +\n    scale_alpha_identity() +\n    scale_x_continuous(breaks = med_chr_lens$MID_TOT, \n                       labels = med_chr_lens$chr) +\n    theme_bw() +\n    theme(panel.grid.major.x = element_blank(),\n          panel.grid.minor.x = element_blank()\n    ) +\n    guides(colour = \"none\") + \n    ggtitle(paste(\"Bin length:\", BIN_LENGTH)) +\n    xlab(\"Chromosome\") +\n    ylab(\"-log10(p-value)\") + \n    geom_hline(yintercept = significance_line, colour = \"#AAF683\", linetype = \"dashed\") +\n    geom_hline(yintercept = suggestive_line, colour = \"#60D394\", linetype = \"dashed\")\n  \n  out = ggplotly(p1, tooltip = c(\"CHROM\", \"BIN_START\", \"BIN_END\"))\n  \n  return(out)\n})"},{"path":"association-testing-with-simulated-phenotypes.html","id":"include-loci-with-missing-genotypes","chapter":"6 Association testing with simulated phenotypes","heading":"6.4.2 Include loci with missing genotypes","text":"","code":""},{"path":"association-testing-with-simulated-phenotypes.html","id":"run-gwas-1","chapter":"6 Association testing with simulated phenotypes","heading":"6.4.2.1 Run GWAS","text":"","code":"\ntest_out_wimiss = file.path(out_dir_test, \"gwls_results\", \"gwas_results_wimiss.rds\")\ngwas_tests_wimiss = purrr::map(final_wimiss, function(BIN_LENGTH){\n  run_gwas(d = BIN_LENGTH$genotypes,\n           m = BIN_LENGTH$positions,\n           p = BIN_LENGTH$phenotypes)\n})\n\nsaveRDS(gwas_tests_wimiss, test_out_wimiss)"},{"path":"association-testing-with-simulated-phenotypes.html","id":"read-in-results-from-snakemake-script","chapter":"6 Association testing with simulated phenotypes","heading":"6.4.2.2 Read in results from Snakemake script","text":"","code":"\ngwas_tests_wimiss = purrr::map(bin_lengths, function(BIN_LENGTH){\n  readRDS(file.path(lts_dir, \"association_testing/20211104_test/test_results\", paste(BIN_LENGTH, \".rds\", sep = \"\")))\n})"},{"path":"association-testing-with-simulated-phenotypes.html","id":"plot-2","chapter":"6 Association testing with simulated phenotypes","heading":"6.4.2.3 Plot","text":"","code":"\n# Create custom Manhattan plot\ngwas_pal = c(\"#2B2D42\", \"#F7B267\", \"#F25C54\")\nnames(gwas_pal) = c(\"target\", \"even chr\", \"odd chr\")\nsignificance_line = 3.6\nsuggestive_line = 2.9\n\ntest_man_wimiss = purrr::map(seq_along(gwas_tests_wimiss), function(COUNTER){\n  # Get bin length\n  BIN_LENGTH = names(gwas_tests_wimiss)[COUNTER] %>% \n    as.numeric(.)\n  \n  # Clean data frame\n  test_results = gwas_tests_wimiss[[COUNTER]]$results %>% \n    dplyr::left_join(med_chr_lens, by = c(\"Chr\" = \"chr\")) %>% \n    # add x-coord\n    dplyr::mutate(X_COORD = pos + TOT) %>% \n    # change column names\n    dplyr::rename(CHROM = Chr, BIN_START = pos) %>% \n    # add BIN_END\n    dplyr::mutate(BIN_END = BIN_START + BIN_LENGTH - 1) %>% \n    # add locus\n    dplyr::mutate(LOCUS = paste(CHROM, BIN_START, sep = \":\")) %>%\n    # target or not\n    dplyr::mutate(TARGET = dplyr::if_else(LOCUS %in% sample_gts[[COUNTER]]$LOCUS,\n                                          \"yes\",\n                                          \"no\"),\n                  TARGET = factor(TARGET, levels = c(\"yes\", \"no\"))) %>% \n    # create vector of colours\n    dplyr::mutate(COLOUR = dplyr::case_when(TARGET == \"yes\" ~ names(gwas_pal)[1],\n                                            gtools::even(CHROM) ~ names(gwas_pal)[2],\n                                            gtools::odd(CHROM) ~ names(gwas_pal)[3]),\n                  # order so that `target` is plotted last, at the front\n                  COLOUR = factor(COLOUR, levels = rev(names(gwas_pal))),\n                  SHAPE = dplyr::if_else(TARGET == \"yes\",\n                                         18,\n                                         20),\n                  SIZE = dplyr::if_else(TARGET == \"yes\",\n                                         1,\n                                         0.5),\n                  ALPHA = dplyr::if_else(TARGET == \"yes\",\n                                         1,\n                                         0.5)\n                  )\n  \n  # Plot\n  p1 = test_results %>% \n    ggplot(aes(x = X_COORD,\n               y = -log10(p_value_REML),\n               colour = COLOUR,\n               shape = SHAPE,\n               size = SIZE,\n               alpha = ALPHA,\n               label = CHROM,\n               label2 = BIN_START,\n               label3 = BIN_END)) + \n    geom_point() +\n    aes(group = rev(TARGET)) +\n    scale_color_manual(values = gwas_pal) +\n    scale_shape_identity() +\n    scale_size_identity() +\n    scale_alpha_identity() +\n    scale_x_continuous(breaks = med_chr_lens$MID_TOT, \n                       labels = med_chr_lens$chr) +\n    theme_bw() +\n    theme(panel.grid.major.x = element_blank(),\n          panel.grid.minor.x = element_blank()\n    ) +\n    guides(colour = \"none\") + \n    ggtitle(paste(\"Bin length:\", BIN_LENGTH)) +\n    xlab(\"Chromosome\") +\n    ylab(\"-log10(p-value)\") + \n    geom_hline(yintercept = significance_line, colour = \"#AAF683\", linetype = \"dashed\") +\n    geom_hline(yintercept = suggestive_line, colour = \"#60D394\", linetype = \"dashed\")\n  \n  out = ggplotly(p1, tooltip = c(\"CHROM\", \"BIN_START\", \"BIN_END\"))\n  \n  return(out)\n\n})\n\ntest_man_wimiss[[1]]"},{"path":"association-testing-with-simulated-phenotypes.html","id":"get-significance-levels-from-permutations","chapter":"6 Association testing with simulated phenotypes","heading":"6.5 Get significance levels from permutations","text":"","code":"\nperm_file = here::here(\"data/20211109_permutation_mins.csv\")\nPERMUTATIONS_DIR = file.path(lts_dir, \"association_testing/20211109_permutations\")\nSITE_FILTERS = c(\"all_sites\", \"no_repeat_sites\", \"no_repeat_reads\"); names(SITE_FILTERS) = SITE_FILTERS\nTARGET_PHENOS = c(\"mean\", \"intercept\"); names(TARGET_PHENOS) = TARGET_PHENOS\nBIN_LENGTHS = c(5000, 10000, 15000, 20000); names(BIN_LENGTHS) = BIN_LENGTHS\nN_PERMUTATIONS = 1:10\n\nperms_df = purrr::map_dfr(SITE_FILTERS, function(SITE_FILTER){\n  purrr::map_dfr(TARGET_PHENOS, function(TARGET_PHENO){\n    purrr::map_dfr(BIN_LENGTHS, function(BIN_LENGTH){\n      purrr::map_dfr(N_PERMUTATIONS, function(N_PERM){\n        in_list = readRDS(file.path(PERMUTATIONS_DIR, SITE_FILTER, TARGET_PHENO, BIN_LENGTH, paste(N_PERM, \".rds\", sep = \"\")))\n        # Pull out minimum\n        out_df = tibble::tibble(MIN_P = in_list$results$p_value_REML %>%\n                                  min()\n        )\n      }, .id = \"PERMUTATION\")\n    }, .id = \"BIN_LENGTH\")\n  }, .id = \"TARGET_PHENO\")\n}, .id = \"SITE_FILTER\")\n\n# Get minimum\nperms_df_mins = perms_df %>% \n  dplyr::group_by(SITE_FILTER, TARGET_PHENO, BIN_LENGTH) %>% \n  dplyr::summarise(MIN_P = min(MIN_P))\n\nreadr::write_csv(perms_df_mins,\n                 perm_file)\nperms_df_mins %>% \n  DT::datatable()"},{"path":"gwls-results.html","id":"gwls-results","chapter":"7 GWLS results","heading":"7 GWLS results","text":"","code":"\nlibrary(here)\nsource(here::here(\"book/source/04-Association_testing.R\"))"},{"path":"gwls-results.html","id":"notes","chapter":"7 GWLS results","heading":"7.1 Notes","text":"20211104 association test performed full sites file. Results : /nfs/research/birney/users/ian/somites/association_testing/20211104_true/results20211109 association test performed sites excluding overlapping repeat regions. Results : /nfs/research/birney/users/ian/somites/association_testing/20211109_true/results","code":""},{"path":"gwls-results.html","id":"phenotype-data","chapter":"7 GWLS results","heading":"7.2 Phenotype data","text":"First 400 phenotype data: https://github.com/brettellebi/somites/tree/master/data/20210917_First400_F2_DF.xlsx.also attach DataFrame phenotyping first 400 F2s (First400_F2_DF.xlsx)…interest us association testing :\nintercept period -> intercept table\nmean period -> mean table","code":""},{"path":"gwls-results.html","id":"snakemake-rules","chapter":"7 GWLS results","heading":"7.3 Snakemake rules","text":"Snakemake rules running GWAS phenotypes: https://github.com/brettellebi/somites/blob/master/workflow/rules/07_assocation_testing.smk","code":""},{"path":"gwls-results.html","id":"results","chapter":"7 GWLS results","heading":"7.4 Results","text":"","code":""},{"path":"gwls-results.html","id":"all-sites","chapter":"7 GWLS results","heading":"7.4.1 All sites","text":"","code":""},{"path":"gwls-results.html","id":"read-in-files","chapter":"7 GWLS results","heading":"7.4.1.1 Read in files","text":"","code":"\ntarget_phenos = c(\"mean\", \"intercept\")\nnames(target_phenos) = target_phenos\nbin_lengths = c(5000, 10000, 15000, 20000)\nnames(bin_lengths) = bin_lengths\nresults_dir = \"/nfs/research/birney/users/ian/somites/association_testing/20211109_true/all_sites/results/\"\n\ngwas_true = purrr::map(target_phenos, function(PHENO){\n  purrr::map(bin_lengths, function(BIN_LENGTH){\n    readRDS(file.path(results_dir, PHENO, paste(BIN_LENGTH, \".rds\", sep = \"\")))\n  })\n})"},{"path":"gwls-results.html","id":"manhattans","chapter":"7 GWLS results","heading":"7.4.1.2 Manhattans","text":"Process dataRead significance levels permutationsPlot","code":"\nplot_dat = purrr::map(seq_along(gwas_true), function(COUNTER_1){\n  bin_list = purrr::map(seq_along(gwas_true[[COUNTER_1]]), function(COUNTER_2){\n    BIN_LENGTH = names(gwas_true[[COUNTER_1]])[COUNTER_2] %>% \n      as.numeric()\n    out = clean_gwas_res(gwas_true[[COUNTER_1]][[COUNTER_2]],\n                         bin_length = BIN_LENGTH,\n                         chr_lens = med_chr_lens)\n    \n    return(out)\n  })\n  names(bin_list) = names(gwas_true[[COUNTER_1]])\n  \n  return(bin_list)\n})\nnames(plot_dat) = names(gwas_true)\nperm_file = here::here(\"data/20211109_permutation_mins.csv\")\nperms_df_mins = readr::read_csv(perm_file,\n                                col_types = c(\"ccid\"))\nplot_dir = here::here(\"book/plots/20211109/gwls_results/all_sites\")\n# Plot\nlapply(seq_along(plot_dat), function(COUNTER_PHENO){\n  lapply(seq_along(plot_dat[[COUNTER_PHENO]]), function(COUNTER_BINL){\n    # Get pheno\n    PHENO = names(plot_dat)[COUNTER_PHENO]\n    # Get bin length\n    BINL = names(plot_dat[[COUNTER_PHENO]])[COUNTER_BINL] %>% \n      as.numeric()\n    # Get significant level\n    SIG_LEVEL = perms_df_mins %>%\n      dplyr::filter(SITE_FILTER == \"all_sites\", TARGET_PHENO == PHENO, BIN_LENGTH == BINL) %>% \n      dplyr::pull(MIN_P) %>% \n      -log10(.)\n    \n    # Plot\n    out = plot_man(plot_dat[[COUNTER_PHENO]][[COUNTER_BINL]],\n             phenotype = PHENO,\n             bin_length = BINL,\n             gwas_pal = gwas_pal[2:3],\n             med_chr_lens = med_chr_lens,\n             sig_line = SIG_LEVEL) +\n      ylim(0,7)\n    \n    ggsave(file.path(plot_dir, paste(PHENO, \"_\", BINL, \".png\", sep = \"\")),\n           out,\n           device = \"png\",\n           width = 9.6,\n           height = 6,\n           units = \"in\",\n           dpi = 400)\n    \n    out\n  })\n})\n#> [[1]]\n#> [[1]][[1]]#> \n#> [[1]][[2]]#> \n#> [[1]][[3]]#> \n#> [[1]][[4]]#> \n#> \n#> [[2]]\n#> [[2]][[1]]#> \n#> [[2]][[2]]#> \n#> [[2]][[3]]#> \n#> [[2]][[4]]"},{"path":"gwls-results.html","id":"excluding-reads-overlapping-repeats","chapter":"7 GWLS results","heading":"7.4.2 Excluding reads overlapping repeats","text":"","code":""},{"path":"gwls-results.html","id":"read-in-files-1","chapter":"7 GWLS results","heading":"7.4.2.1 Read in files","text":"","code":"\nfilter_type = \"no_repeat_reads\"\ntarget_phenos = c(\"mean\", \"intercept\")\nnames(target_phenos) = target_phenos\nbin_lengths = c(5000, 10000, 15000, 20000)\nnames(bin_lengths) = bin_lengths\nresults_dir = file.path(\"/nfs/research/birney/users/ian/somites/association_testing/20211109_true\", filter_type, \"results\")\n\ngwas_true = purrr::map(target_phenos, function(PHENO){\n  purrr::map(bin_lengths, function(BIN_LENGTH){\n    readRDS(file.path(results_dir, PHENO, paste(BIN_LENGTH, \".rds\", sep = \"\")))\n  })\n})"},{"path":"gwls-results.html","id":"manhattans-1","chapter":"7 GWLS results","heading":"7.4.2.2 Manhattans","text":"Process dataRead significance levels permutationsPlot","code":"\nplot_dat = purrr::map(seq_along(gwas_true), function(COUNTER_1){\n  bin_list = purrr::map(seq_along(gwas_true[[COUNTER_1]]), function(COUNTER_2){\n    BIN_LENGTH = names(gwas_true[[COUNTER_1]])[COUNTER_2] %>% \n      as.numeric()\n    out = clean_gwas_res(gwas_true[[COUNTER_1]][[COUNTER_2]],\n                         bin_length = BIN_LENGTH,\n                         chr_lens = med_chr_lens)\n    \n    return(out)\n  })\n  names(bin_list) = names(gwas_true[[COUNTER_1]])\n  \n  return(bin_list)\n})\nnames(plot_dat) = names(gwas_true)\nperm_file = here::here(\"data/20211109_permutation_mins.csv\")\nperms_df_mins = readr::read_csv(perm_file,\n                                col_types = c(\"ccid\"))\nplot_dir = here::here(file.path(\"book/plots/20211109/gwls_results\", filter_type))\n# Plot\nlapply(seq_along(plot_dat), function(COUNTER_PHENO){\n  lapply(seq_along(plot_dat[[COUNTER_PHENO]]), function(COUNTER_BINL){\n    # Get pheno\n    PHENO = names(plot_dat)[COUNTER_PHENO]\n    # Get bin length\n    BINL = names(plot_dat[[COUNTER_PHENO]])[COUNTER_BINL] %>% \n      as.numeric()\n    # Get significant level\n    SIG_LEVEL = perms_df_mins %>%\n      dplyr::filter(SITE_FILTER == filter_type, TARGET_PHENO == PHENO, BIN_LENGTH == BINL) %>% \n      dplyr::pull(MIN_P) %>% \n      -log10(.)\n    \n    # Plot\n    out = plot_man(plot_dat[[COUNTER_PHENO]][[COUNTER_BINL]],\n             phenotype = PHENO,\n             bin_length = BINL,\n             gwas_pal = gwas_pal[2:3],\n             med_chr_lens = med_chr_lens,\n             sig_line = SIG_LEVEL) +\n      ylim(0,7)\n    \n    ggsave(file.path(plot_dir, paste(PHENO, \"_\", BINL, \".png\", sep = \"\")),\n           out,\n           device = \"png\",\n           width = 9.6,\n           height = 6,\n           units = \"in\",\n           dpi = 400)\n    \n    out\n  })\n})\n#> [[1]]\n#> [[1]][[1]]#> \n#> [[1]][[2]]#> \n#> [[1]][[3]]#> \n#> [[1]][[4]]#> \n#> \n#> [[2]]\n#> [[2]][[1]]#> \n#> [[2]][[2]]#> \n#> [[2]][[3]]#> \n#> [[2]][[4]]"}]
